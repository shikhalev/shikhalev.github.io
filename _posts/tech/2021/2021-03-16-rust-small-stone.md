---
title: Небольшой подводный камень в Rust
description: Нечастый случай, когда Rust (его стандартная библиотека) прямо-таки подталкивает сделать ошибку по невнимательности при чтении из файла в вектор.
category: [ tech, programming, rust ]
tags:
  - грабли
image: /assets/img/2021-03/rust_logo.png
recommend: true
---
{% include image.liquid place="right" width=256 src="/assets/img/ico/rust.png" alt="Логотип Rust" class="logo" %}

Обнаружил тут некоторый подводный камень в стандартной библиотеке Rust. Багом это назвать, конечно, нельзя,
просто такой момент, где можно по собственной невнимательности наступить на грабли и не сразу это заметить, что
нехарактерно для Rust.

Опасность подстерегает нас, когда мы читаем данные из файла посредством `std::​fs::​File.read()`[^read], *не используя*
при этом `std::io::BufReader`[^bufreader], а самостоятельно выделяя блок памяти и читая в него.

Подводный камень тут вот в чем, цитирую документацию:

> if `n` is `0`, then it can indicate one of two scenarios:
>
> * This reader has reached its "end of file" and will likely no longer be able to produce bytes. Note that this
>   does not mean that the reader will always no longer be able to produce bytes.
> * <u>The buffer specified was 0 bytes in length.</u>

Подчеркивание мое. Итак, если мы передаем методу `read()` буфер нулевой длины, то результат будет ровно тот же самый,
что и если мы достигли конца файла, т.е. `Ok(0)`.

<!--more-->

В каких случаях можно на это напороться? Мой пример (немного упрощенно) — для файла надо подсчитать контрольную сумму,
считается она при помощи крейта `crc64fast`[^crc64fast], где метод `Digest.write()`[^write] берет на вход `&[u8]`, почему
собственно я и использую чтение в собственный буфер без прослоек. Выглядит это примерно так, для примера:

{% highlight rust %}
pub fn crc64(path: &PathBuf) -> io::Result<u64> {
  let mut file = fs::File::open(&path)?;
  let mut buffer = [0; 1024];
  let mut digest = Digest::new();
  loop {
    let l = file.read(&mut buffer)?;
    if l == 0 {
      break;
    }
    digest.write(&buffer[0..l]);
  }
  Ok(digest.sum64())
}
{% endhighlight %}

В примере я поместил статический буфер. Именно в таком виде и именно с таким циклом можно найти кучу примеров в сети.
С ним все хорошо, кроме того, что размер задается при компиляции. Захотел я это дело параметризовать и напоролся на гра­б­ли.
Просто потому что поначалу решил выделять память так[^wc]:

{% highlight rust %}
let mut buffer = Vec::<u8>::with_capacity(buffer_size);
{% endhighlight %}

~~*(Слава [турборыбе][turbofish]!)*~~ Ну, в самом деле, мне же нужно выделить память, а не проинициализировать ее — все равно перезапишется
при чтении. В чем тут подвох? Подвох в том, что превращаясь в `&mut [u8]` такой вектор демонстрирует именно что нулевую
длину. И никаких ошибок я при этом не получаю, просто все файлы почему-то кончаются, не успев начаться. Хорошо, что у меня
была достаточно простая в целом задача, я логировал множество промежуточных моментов и заметил, что контрольные суммы как-то
подозрительно одинаковые...

Пришлось переделать:

{% highlight rust%}
let mut buffer = vec![0; buffer_size];
{% endhighlight %}

Получил избыточную (в данном месте) инициализацию, но не очень представляю, как бы можно было без нее обойтись, не прибегая
к `unsafe` (а прибегать к нему не хотелось бы из соображений чистоты кода).

Повторюсь, такое поведение стандартной библиотеки, безусловно, не баг. Но, на мой взгляд, просчет дизайна, который
*не помогает* писать правильно, а наоборот — незаметно подталкивает к ошибке.

Лично я сделал бы передачу буфера нулевой длины ошибочной ситуацией (метод `read()` возвращает `Result<usize>`, так что
с этим нет проблем), поскольку не вижу, в каких ситуациях это было бы нормально. Возможно, так сделано для симметрии
с методами записи, где передача пустого буфера действительно может быть штатным случаем.


[logo]: /assets/img/2021-03/rust_logo.png

[^crc64fast]: <https://crates.io/crates/crc64fast>
[^read]: <https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read>
[^write]: <https://docs.rs/crc64fast/1.0.0/crc64fast/struct.Digest.html#method.write>
[^bufreader]: <https://doc.rust-lang.org/std/io/struct.BufReader.html>
[^wc]: <https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity>

[turbofish]: https://turbo.fish/
