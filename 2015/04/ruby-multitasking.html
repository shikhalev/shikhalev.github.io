<!DOCTYPE html>

<html lang="ru">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/" title="CC BY-SA 4.0">
  <meta name="license" content="CC BY-SA 4.0">
  <link rel="icon" href="https://shikhalev.github.io/favicon.svg" type="image/svg+xml">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link rel="stylesheet" href="/assets/styles.css" type="text/css">
  

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ruby и многозадачность | Иван Шихалев</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Ruby и многозадачность" />
<meta name="author" content="Иван Шихалев" />
<meta property="og:locale" content="ru" />
<meta name="description" content="В статье рассматриваются основные средства работы с потоками (threads) и процессами в языке и стандартной библиотеке Ruby." />
<meta property="og:description" content="В статье рассматриваются основные средства работы с потоками (threads) и процессами в языке и стандартной библиотеке Ruby." />
<link rel="canonical" href="https://shikhalev.github.io/2015/04/ruby-multitasking.html" />
<meta property="og:url" content="https://shikhalev.github.io/2015/04/ruby-multitasking.html" />
<meta property="og:site_name" content="Иван Шихалев" />
<meta property="og:image" content="https://shikhalev.github.io/img/2015/04/04/ruby-multitasking/screen-multitask-640x640-500-261-0-0.webp" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-04-04T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://shikhalev.github.io/img/2015/04/04/ruby-multitasking/screen-multitask-640x640-500-261-0-0.webp" />
<meta property="twitter:title" content="Ruby и многозадачность" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Иван Шихалев"},"dateModified":"2015-04-04T00:00:00+00:00","datePublished":"2015-04-04T00:00:00+00:00","description":"В статье рассматриваются основные средства работы с потоками (threads) и процессами в языке и стандартной библиотеке Ruby.","headline":"Ruby и многозадачность","image":"https://shikhalev.github.io/img/2015/04/04/ruby-multitasking/screen-multitask-640x640-500-261-0-0.webp","mainEntityOfPage":{"@type":"WebPage","@id":"https://shikhalev.github.io/2015/04/ruby-multitasking.html"},"url":"https://shikhalev.github.io/2015/04/ruby-multitasking.html"}</script>
<!-- End Jekyll SEO tag -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-QCHKX2MX1B"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-QCHKX2MX1B');
</script>


    <!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();
   for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
   k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://cdn.jsdelivr.net/npm/yandex-metrica-watch/tag.js", "ym");

   ym(72960469, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/72960469" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter --></head>

<body>

<div id="global-box">

<div id="watermark-container">
  <div id="watermark">shikhalev.org</div>
</div>

<div id="grid">

<header id="site-header"><p class="logo"><a href="/">Иван Шихалев</a></p></header>

<nav id="navy"><div class="wrapper">
  <input type="checkbox" id="navy-check">
  <label for="navy-check">
    <span id="menu-icon" class="fas">&#xf0c9;</span>
  </label>
  <div id="navy-menu"><a class="navy-item fa-icon-laptop-code" href="/tech/">Технологии</a><a class="navy-item fa-icon-camera" href="/photo/">Фото</a><a class="navy-item fa-icon-newspaper" href="/life/">Жизнь</a><a class="navy-item fa-icon-feather" href="/text/">Тексты</a><a class="navy-item fa-icon-id-card" href="/about/">О себе</a></div>
</div></nav>

<main id="main"><aside class="categories">
  <a class="fa-icon-home" href="/" title="Главная страница сайта"></a>​<a class="fa-icon-laptop-code" href="/tech/" title="Цифровой мир, как он есть, и немного, каким должен быть">Технологии</a>​<a class="fa-icon-keyboard" href="/tech/programming/" title="Языки программирования, алгоритмы, фреймворки, библиотеки и тому подобное">Программирование</a>​<a class="fa-icon-gem" href="/tech/programming/ruby/" title="Язык программирования Ruby">Ruby</a>​<a class="fa-icon-university" href="/pub/" title="Публикации в СМИ">Публикации</a>​<a class="fa-icon-university" href="/pub/samag/" title="Публикации в журнале «Системный администратор»">«Системный администратор»</a></aside>
<article class="layout-post" itemscope itemtype="http://schema.org/BlogPosting"><header class="page-header"><h1 class="title-post" itemprop="name headline">Ruby и многозадачность</h1><aside class="share">
  <a class="fab" target="_blank" title="Поделиться во ВКонтакте" href="https://vk.com/share.php?url=https%3A%2F%2Fshikhalev.github.io%2F2015%2F04%2Fruby-multitasking.html">&#xf189;</a>
  <a class="fab" target="_blank" title="Поделиться в Фейсбуке" href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fshikhalev.github.io%2F2015%2F04%2Fruby-multitasking.html">&#xf39e;</a>
  <a class="fab" target="_blank" title="Поделиться в Телеграме" href="https://t.me/share/url?url=https%3A%2F%2Fshikhalev.github.io%2F2015%2F04%2Fruby-multitasking.html">&#xf3fe;</a>
  <a class="fab" target="_blank" title="Поделиться в Твиттере" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fshikhalev.github.io%2F2015%2F04%2Fruby-multitasking.html&text=Ruby+%D0%B8+%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C">&#xf099;</a>
  <a class="fab" target="_blank" title="Сохранить ссылку в Evernote" href="https://www.evernote.com/clip.action?title=Ruby+%D0%B8+%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C&url=https%3A%2F%2Fshikhalev.github.io%2F2015%2F04%2Fruby-multitasking.html">&#xf839;</a>
</aside>
<p class="meta">
  <time datetime="2015-04-04T00:00:00+00:00" itemprop="datePublished">2015.04.04
  </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Иван Шихалев</span></span></p><aside class="tags">​<a class="tag" href="/tags#многозадачность">многозадачность</a>​<a class="tag" href="/tags#многопоточность">многопоточность</a>​<a class="tag" href="/tags#оптимизация">оптимизация</a></aside></header><div itemprop="articleBody">
  <p><a href="http://samag.ru/archive/article/2645">Оригинал этой статьи опубликован в журнале «Системный администратор» №3 (136) за март 2014</a>.</p>

<hr>

<figure class="__figure __implicit_figure __right" style="max-width:158px;padding: 5px;"><a href="http://samag.ru/archive/article/2645"><img src="/img/2015/04/04/ruby-multitasking/136-158.webp" class="__image"></a></figure>

<div class="note">
  <p><strong>В статье рассматриваются основные средства работы с потоками (threads) и процессами в языке и стандартной библиотеке Ruby</strong></p>

  <p>Немного о терминологии: англоязычный термин «thread» на русский переводится в двух вариантах — как «поток» и как «нить».
Второй вариант точнее и не вызывает неоднозначности с потоками данных (streams), однако первый уже прижился в качестве основного.
Кроме того, есть еще производные термины и варианты вроде «многонитевость» (или «многонитность»), но они мне не встречались и,
честно говоря, режут глаз. Поэтому я буду использовать «поток».</p>
</div>

<p>Прежде, чем перейти к описаниям имеющегося инструментария, хотелось бы заметить, что Ruby создавался не как специальный язык
параллельного программирования, при этом во время его создания и становления многозадачность уже стала привычной и необходимой.
Из этих двух посылок, в об­щем-то, можно вывести текущую картину: никаких специфических концепций мы в нем не увидим, только
поддержку привычной для всех языков общего назначения модели с некоторыми нюансами реализации.</p>

<!--more-->

<h2 id="многопоточность">
<a class="anchor" href="#%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C" aria-hidden="true"><span class="octicon octicon-link"></span></a>Многопоточность</h2>

<p>Потоки позволяют программисту распараллелить выполнение задачи в рамках одного процесса. Это дает заметный выигрыш в двух основных
случаях: во-первых, когда есть аппаратные ресурсы для параллельных вычислений, т.е. многоядерная или многопроцессорная архитектура
(что для современных компьютеров норма), и во-вторых, когда какие-то подзадачи вынуждены тратить время на ожидание внешних ресурсов,
будь то дисковая подсистема, сеть, или действия пользователя.</p>

<p>Плохая новость в том, что в действительности потоки Ruby не параллельны, и выигрыша от многоядерности нам получить не удастся.
Несмотря на то, что актуальные версии интерпретатора используют потоки операционной системы, управление ими построено так, что
в определенный момент времени выполняется только один поток. В старых версиях (по 1.8.7 включительно) использовались так называемые
«зеленые» потоки, исполняющиеся в рамках одного системного, в новых — действует механизм GIL (global interpreter lock). Хорошей же
новостью можно считать то, что этот механизм защищает от некоторых (но не всех) потенциальных конфликтов между потоками.
Ниже о синхронизации еще поговорим, а пока отметим, что второй выигрыш — в случае ожидания внешних ресурсов — нам остается вполне
доступен, таким образом, польза от использования потоков в Ruby безусловно есть.</p>

<p>Работа с потоками в Ruby в основном сосредоточена в классе <code class="language-plaintext highlighter-rouge">Thread</code> — в самом простом случае мы создаем объект этого класса из блока
(или множество объектов) и ждем завершения<sup id="fnref:gist"><a href="#fn:gist" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="nb">puts</span> <span class="s1">'begin'</span>

<span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">i</span> <span class="p">}</span>
<span class="k">end</span>

<span class="c1"># sleep 0</span>
<span class="nb">puts</span> <span class="s1">'---'</span>

<span class="n">th</span><span class="p">.</span><span class="nf">join</span>

<span class="nb">puts</span> <span class="s1">'end'</span></code></pre>
</figure>

<p>Результат будет такой:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo01.rb
<span class="go">begin
---
1
2
3
end</span></code></pre>
</figure>

<p>Если же мы раскомментируем строчку «<code class="language-plaintext highlighter-rouge">sleep 0</code>», положение строки с дефисами относительно цифр станет непредсказуемым,
а если вместо ноля напишем «<code class="language-plaintext highlighter-rouge">1</code>», или даже «<code class="language-plaintext highlighter-rouge">0.1</code>», дефисы будут стабильно выводиться после тройки, поскольку поток
полностью отработает раньше.</p>

<p>Что еще можно сделать с потоком, кроме как запустить его, и смиренно дождаться завершения (именно это делает метод <code class="language-plaintext highlighter-rouge">join</code>)?
Можно его приостановить (метод класса <code class="language-plaintext highlighter-rouge">Thread.stop</code>, вызываемый внутри потока), «разбудить», т.е. продолжить выполнение
с момента остановки (<code class="language-plaintext highlighter-rouge">wakeup</code>), прекратить, не дожидаясь окончания работы (<code class="language-plaintext highlighter-rouge">terminate</code>)… Такой пример:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s1">'started'</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">stop</span>
  <span class="nb">puts</span> <span class="s1">'continued'</span>
  <span class="nb">sleep</span> <span class="mi">100</span>
  <span class="nb">puts</span> <span class="s1">'finished'</span>
<span class="k">end</span>

<span class="nb">sleep</span> <span class="mf">0.1</span>
<span class="nb">puts</span> <span class="s1">'wakeup'</span>
<span class="n">th</span><span class="p">.</span><span class="nf">wakeup</span>
<span class="nb">sleep</span> <span class="mi">0</span>
<span class="nb">puts</span> <span class="s1">'terminate'</span>
<span class="n">th</span><span class="p">.</span><span class="nf">terminate</span>
<span class="n">th</span><span class="p">.</span><span class="nf">join</span></code></pre>
</figure>

<p>Даст следующий вывод:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo02.rb
<span class="go">started
wakeup
continued
terminate</span></code></pre>
</figure>

<p>Причем, если мы закомментируем строку «<code class="language-plaintext highlighter-rouge">sleep 0</code>», то до «<code class="language-plaintext highlighter-rouge">continued</code>» дело может и не дойти.</p>

<h3 id="обмен-данными-между-потоками">
<a class="anchor" href="#%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0%D0%BC%D0%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a>Обмен данными между потоками</h3>

<p><em>Во-первых,</em> мы можем передавать блоку аргументы при создании потока:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">|</span> <span class="o">...</span> <span class="p">}</span></code></pre>
</figure>

<p><em>Во-вторых,</em> в Ruby любой код возвращает какое-то значение, и результат выполнения блока мы вполне можем получить —
для этого нужно использовать метод <code class="language-plaintext highlighter-rouge">value</code> вместо <code class="language-plaintext highlighter-rouge">join</code>.</p>

<p><em>В-третьих,</em> блок, из которого создается поток, как и любой другой, образует замыкание, т.е. в нем можно обращаться
к любым данным, доступным в месте его объявления<sup id="fnref:context"><a href="#fn:context" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>. Однако здесь нужно помнить о том, что разные потоки могут
обращаться к одним и тем же данным в произвольном порядке.</p>

<p>От одновременного обращения двух потоков к одной переменной нас защищает GIL, о котором было сказано выше,
он же делает многие (но не все) стандартные методы стандартных классов атомарными, но этого недостаточно.
Сколько раз выведет «<code class="language-plaintext highlighter-rouge">true</code>» следующий код?</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">flag</span> <span class="o">=</span> <span class="kp">true</span>

<span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s1">'true'</span> <span class="k">if</span> <span class="n">flag</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Thread</span><span class="p">.</span><span class="nf">list</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">th</span><span class="o">|</span>
  <span class="k">if</span> <span class="n">th</span> <span class="o">!=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span>
    <span class="n">th</span><span class="p">.</span><span class="nf">join</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>Правильный ответ: непредсказуемо, если запустить скрипт достаточно много раз, можно увидеть все варианты от одного до пяти.
Хотя проверка флага и присвоение ему значения сами по себе атомарны и не вызывают конфликтов, <em>между ними</em> легко может произойти
переключение между потоками.</p>

<p>Самый простой способ обеспечить синхронизацию — использовать метод <code class="language-plaintext highlighter-rouge">Thread.exclusive</code>, в предыдущем примере это бы выглядело так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="no">Thread</span><span class="p">.</span><span class="nf">exclusive</span> <span class="k">do</span>
      <span class="nb">puts</span> <span class="s1">'true'</span> <span class="k">if</span> <span class="n">flag</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>В более сложных случаях, когда у нас, например, две переменные, обращение к каждой из которых нужно синхронизировать
независимо друг от друга, следует использовать объекты класса <code class="language-plaintext highlighter-rouge">Mutex</code> и их метод <code class="language-plaintext highlighter-rouge">synchronize</code>.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">alpha</span> <span class="o">=</span> <span class="kp">true</span>
<span class="n">alpha_m</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
<span class="n">beta</span> <span class="o">=</span> <span class="kp">true</span>
<span class="n">beta_m</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>

<span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">alpha_m</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="nb">puts</span> <span class="s1">'alpha'</span> <span class="k">if</span> <span class="n">alpha</span>
      <span class="n">alpha</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>
    <span class="n">beta_m</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="nb">puts</span> <span class="s1">'beta'</span> <span class="k">if</span> <span class="n">beta</span>
      <span class="n">beta</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>Собственно, <code class="language-plaintext highlighter-rouge">Thread.exclusive</code> делает то же самое, но при этом использует один и тот же объект класса <code class="language-plaintext highlighter-rouge">Mutex</code> на все случаи.</p>

<p>Кроме такой безусловной синхронизации объекты <code class="language-plaintext highlighter-rouge">Mutex</code> позволяют и более гибко работать с блокировками — в каких-то случаях
не дожидаться освобождения заблокированного объекта, а выполнить другие действия (например, вывести сообщение об ошибке).
А еще ручное блокирование/разблокирование дает простор для глупых ошибок по невнимательности, поэтому я бы не рекомендовал
им пользоваться без особой на то необходимости.</p>

<p><em>В-четвертых,</em> мы можем получать и устанавливать так называемые переменные потока посредством методов <code class="language-plaintext highlighter-rouge">thread_variable_get</code>/<code class="language-plaintext highlighter-rouge">set</code>.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">sleep</span> <span class="mf">0.1</span>
  <span class="nb">p</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">thread_variable_get</span> <span class="s1">'alpha'</span>
<span class="k">end</span>

<span class="n">th</span><span class="p">.</span><span class="nf">thread_variable_set</span> <span class="s1">'alpha'</span><span class="p">,</span> <span class="ss">:alpha</span>

<span class="n">th</span><span class="p">.</span><span class="nf">join</span></code></pre>
</figure>

<p>Сюда же отнесем обращение к переменным, принадлежащим текущему «волокну» (fiber) потока — пример выше можно переписать так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">sleep</span> <span class="mf">0.1</span>
  <span class="nb">p</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="s1">'alpha'</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">th</span><span class="p">[</span><span class="s1">'alpha'</span><span class="p">]</span> <span class="o">=</span> <span class="ss">:alpha</span>

<span class="n">th</span><span class="p">.</span><span class="nf">join</span></code></pre>
</figure>

<p>Это короче и наглядней, но надо помнить, что в общем случае «волокна» могут меняться.</p>

<p>И, <em>в-пятых,</em> для потоков применимы описываемые ниже способы взаимодействия между процессами.</p>

<h3 id="отступление-о-волокнах">
<a class="anchor" href="#%D0%BE%D1%82%D1%81%D1%82%D1%83%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE-%D0%B2%D0%BE%D0%BB%D0%BE%D0%BA%D0%BD%D0%B0%D1%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>Отступление о «волокнах»</h3>

<p>«Волокна» (fibers) имеют косвенное отношение к теме статьи, но не упомянуть их нельзя, хотя бы
из-за вышеописанного обращения к fiber-local переменным. По сути это сопрограммы, переключение
между которыми происходит не средствами системы (или виртуальной машины), а вручную. Еще их можно
охарактеризовать как подпрограммы, выполнение которых при каждом вызове начинается с того момента,
на котором было остановлено в прошлый раз. Поясню примером:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">f</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">current</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">new</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">current</span>
    <span class="n">current</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">new</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span> <span class="p">[</span><span class="n">last</span><span class="p">,</span> <span class="n">current</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="nb">p</span> <span class="n">f</span><span class="p">.</span><span class="nf">resume</span>
  <span class="nb">sleep</span> <span class="mi">1</span>
<span class="k">end</span></code></pre>
</figure>

<p>В результате получим последовательность пар значений времени предыдущего вызова и текущего.</p>

<p>В целом, это довольно экзотический инструмент, которому в явном виде не так-то просто найти
практическое применение.</p>

<h3 id="дополнительно-о-потоках">
<a class="anchor" href="#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-%D0%BE-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0%D1%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>Дополнительно о потоках</h3>

<p>Для группировки потоков существует класс <code class="language-plaintext highlighter-rouge">ThreadGroup</code>, который не предоставляет никакой особой функциональности,
кроме контроля за тем, что каждый поток принадлежит одной и только одной группе. Не добавленный ни в какую группу
явно, поток принадлежит <code class="language-plaintext highlighter-rouge">ThreadGroup::Default</code>.</p>

<p>Все классы, упомянутые выше, принадлежат ядру языка и загружаются автоматически, однако есть еще кое-какие возможности,
предоставляемые уже модулями стандартной библиотеки<sup id="fnref:stdlib"><a href="#fn:stdlib" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>. Так, «<code class="language-plaintext highlighter-rouge">require 'thread'</code>» предоставит нам классы <code class="language-plaintext highlighter-rouge">Queue</code>
и <code class="language-plaintext highlighter-rouge">SizedQueue</code>, с функциональностью очереди, как ясно из названия. Во втором случае объем очереди ограничен,
и при достижении ограничения помещение нового элемента будет дожидаться, пока другой поток освободит место.</p>

<p>Еще одна полезная библиотека («<code class="language-plaintext highlighter-rouge">require 'thwait'</code>» и класс <code class="language-plaintext highlighter-rouge">ThreadsWait</code>) позволяет ожидать завершения некоего набора
потоков, как всех вместе, так и по очереди.</p>

<h2 id="процессы-в-ruby">
<a class="anchor" href="#%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B-%D0%B2-ruby" aria-hidden="true"><span class="octicon octicon-link"></span></a>Процессы в Ruby</h2>

<p>Собственно запуск программы на Ruby, как и на любом другом языке — есть запуск процесса. Который, в свою очередь,
может порождать дочерние и общаться как с ними, так и с совершенно независимыми от него. Ключевое отличие дочернего
процесса от потока — независимое адресное пространство — разные процессы не могут никаким образом обращаться к переменным
друг друга.</p>

<p>С точки зрения программиста дочерние процессы делятся на два принципиально разных вида: подпроцессы, порождаемые
из того же кода посредством <code class="language-plaintext highlighter-rouge">fork</code>, и внешние программы.</p>

<p>Как работает <code class="language-plaintext highlighter-rouge">fork</code>? В привычных языках, типа C — это функция, в родительском процессе возвращающая идентификатор дочернего,
а в дочернем — ноль. В Ruby можно ее использовать точно так же, однако более элегантно воспользоваться вариантом с блоком,
который и станет выполняться в дочернем процессе.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span> <span class="k">do</span>
  <span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="nb">sleep</span> <span class="mf">0.01</span>
    <span class="nb">puts</span> <span class="s2">"Child [</span><span class="si">#{</span><span class="no">Process</span><span class="p">.</span><span class="nf">pid</span><span class="si">}</span><span class="s2">]: </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="nb">sleep</span> <span class="mf">0.01</span>
  <span class="nb">puts</span> <span class="s2">"Parent [</span><span class="si">#{</span><span class="no">Process</span><span class="p">.</span><span class="nf">pid</span><span class="si">}</span><span class="s2">]: </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">waitpid</span> <span class="n">pid</span></code></pre>
</figure>

<p>Должен получиться примерно такой вывод:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo09.rb
<span class="go">Parent [9032]: 0
Child [9034]: 0
Parent [9032]: 1
Child [9034]: 1
Parent [9032]: 2
Child [9034]: 2</span></code></pre>
</figure>

<p>Что здесь важно помнить, так это то, что хотя блок при <code class="language-plaintext highlighter-rouge">fork</code> и является замыканием, он получает доступ не к тому же окружению,
в котором определен, а <em>к его копии</em> на момент запуска. Таким образом обмен данными посредством внешних переменных невозможен,
а вопрос о синхронизации не имеет смысла.</p>

<p>Что касается внешних программ, то для их вызова служит несколько методов:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">spawn</code> — асинхронный вызов, который нас и будет интересовать, возвращает идентификатор процесса;</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">system</code> — синхронный вызов (т.е. метод дожидается завершения), возвращает индикатор успешности вызова;</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">exec</code> — синхронный вызов, в случае неудачи вызывает исключение;</p>
  </li>
  <li>
    <p><code>`command`</code> или <code class="language-plaintext highlighter-rouge">%x{command}</code> — самая простая форма — синхронный вызов, возвращает строку, соответствующую выводу программы.</p>
  </li>
</ul>

<p>Собственно, теме данной статьи соответствует только <code class="language-plaintext highlighter-rouge">spawn</code> как асинхронный. Замечу лишь, что <code class="language-plaintext highlighter-rouge">system</code> и <code class="language-plaintext highlighter-rouge">exec</code> используют те же
аргументы. Аргументы описываются следующим образом:</p>

<figure class="highlight">
  <pre><code class="language-text" data-lang="text">spawn(‹env,› command ‹, args›*, ‹options›) → pid</code></pre>
</figure>

<p>Т.е. в начале идет необязательный параметр, устанавливающий дополнительные переменные окружения, затем команда, затем произвольное
количество необязательных же аргументов, и наконец, если последний параметр — хэш, из него берутся опции, позволяющие управлять
правами доступа, текущим каталогом и, самое главное, перенаправлениями ввода-вывода. В самом же простом случае достаточно указать
только команду.</p>

<h3 id="сигналы">
<a class="anchor" href="#%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D1%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>Сигналы</h3>

<p>Процессы могут посылать друг другу сигналы и как-то на них реагировать. Вообще говоря, сигналы — это скорее механизм
для общения операционной системы с процессами, и большинство из них зарезервировано под специальные нужды, однако
кое-что можно задействовать и в прикладных целях. Выглядит это, например, так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">child</span> <span class="o">=</span> <span class="nb">fork</span> <span class="k">do</span>
  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="no">Signal</span><span class="p">.</span><span class="nf">trap</span> <span class="ss">:USR1</span> <span class="k">do</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">puts</span> <span class="s2">"Signal USR1: </span><span class="si">#{</span><span class="n">count</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="no">Signal</span><span class="p">.</span><span class="nf">trap</span> <span class="ss">:TERM</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s1">'Signal TERM'</span>
    <span class="nb">exit</span>
  <span class="k">end</span>
  <span class="nb">sleep</span> <span class="mi">1000</span>
  <span class="nb">puts</span> <span class="s1">'Ooops!'</span>
<span class="k">end</span>

<span class="no">Signal</span><span class="p">.</span><span class="nf">trap</span> <span class="ss">:CHLD</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s1">'Child died.'</span>
<span class="k">end</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">kill</span> <span class="ss">:USR1</span><span class="p">,</span> <span class="n">child</span>
<span class="nb">sleep</span> <span class="mf">0.01</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">kill</span> <span class="ss">:USR1</span><span class="p">,</span> <span class="n">child</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">kill</span> <span class="ss">:TERM</span><span class="p">,</span> <span class="n">child</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">wait</span></code></pre>
</figure>

<p>В результате должно получиться:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo10.rb
<span class="go">Signal USR1: 1
Signal USR1: 2
Signal TERM
Child died.</span></code></pre>
</figure>

<p>Метод <code class="language-plaintext highlighter-rouge">Process.kill</code> посылает сигнал, а <code class="language-plaintext highlighter-rouge">Signal.trap</code> устанавливает обработчик сигнала. При этом нетрудно видеть,
что сигнал <code class="language-plaintext highlighter-rouge">CHLD</code> мы не посылали — его отправила система, уведомляя родительский процесс о завершении дочернего.
Отдельно стоит обратить внимание на строку «<code class="language-plaintext highlighter-rouge">sleep 0.01</code>» между двумя отправками. Если ее закомментировать,
то сигнал <code class="language-plaintext highlighter-rouge">USR1</code> будет получен дочерним процессом только один раз, поскольку на момент второй отправки первый
еще не будет обработан — сигналы поступают в очередь и уже имеющиеся там не добавляются.</p>

<p>К сожалению, посредством сигналов мы можем сообщить процессу только о наступлении некоторого события, без подробной
информации. А всю информацию между процессами нужно передавать средствами ввода-вывода.</p>

<h3 id="каналы-ввода-вывода">
<a class="anchor" href="#%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB%D1%8B-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>Каналы ввода-вывода</h3>

<p>Общим способом для любых дочерних процессов будет перенаправление ввода-вывода посредством каналов (pipes).
Для внутренних подпроцессов это выглядит так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">child</span> <span class="o">=</span> <span class="nb">fork</span> <span class="k">do</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span> <span class="s1">'From Child'</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="n">msg</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span>
<span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="nb">p</span> <span class="n">msg</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">wait</span></code></pre>
</figure>

<p>Здесь существенно, что оба процесса первым делом закрывают ненужные «концы» канала. Если этого не сделать, то возможны
проблемы с некорректным определением конца файла.</p>

<p>В случае внешних команд все похоже, а «пишущий конец» канала передаем в специальном хэш-значении в последнем параметре spawn:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">child</span> <span class="o">=</span> <span class="n">spawn</span> <span class="s2">"echo 'External Child'"</span><span class="p">,</span>
    <span class="p">[</span> <span class="no">STDERR</span><span class="p">,</span> <span class="no">STDOUT</span> <span class="p">]</span> <span class="o">=&gt;</span> <span class="n">wr</span>

<span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="n">msg</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span>
<span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="nb">p</span> <span class="n">msg</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">wait</span></code></pre>
</figure>

<p>В приведенных примерах использовалась передача данных только в одну сторону, что, конечно, необязательно. Можно создавать
произвольное количество каналов и назначать их как выводу, так и вводу.</p>

<h3 id="сокеты">
<a class="anchor" href="#%D1%81%D0%BE%D0%BA%D0%B5%D1%82%D1%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>Сокеты</h3>

<p>Сокеты — это совсем универсальный механизм взаимодействия произвольных программ между собою, в том числе и по сети.
Здесь уже не важно, как и где запускается процесс-собеседник, нужно только знать адрес и протокол обмена (формат данных).
Сам по себе стандарт сокетов довольно низкоуровневый, так что подробное описание и примеры заняли бы слишком много места.
Отмечу лишь, что инструменты работы с сокетами находятся в модуле <code class="language-plaintext highlighter-rouge">socket</code> стандартной библиотеки.</p>

<p>Кроме того, на сокетах основано взаимодействие уже максимального уровня — готовыми ruby-объектами в библиотеке dRuby,
о которой я писал в одной из предыдущих статей<sup id="fnref:druby"><a href="#fn:druby" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>. Здесь же стоит сказать, что dRuby позволяет обращаться к объекту
в другом процессе (и, возможно, на другой машине) как к локальному объекту Ruby со всеми его методами, свойствами и т.д.</p>

<h2 id="применение">
<a class="anchor" href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a>Применение</h2>

<p>Подведем некоторые итоги.</p>

<p>При использовании <em>потоков</em> мы остаемся в рамках одного процесса, что определяет как плюсы, так и минусы: с одной стороны,
возможность использования общих переменных, с другой — взаимная зависимость. Дополнительный минус именно ruby-реализации —
глобальный блокировщик, из-за которого реально в любой момент времени выполняется только один поток. Следует однако понимать,
что GIL — это именно особенность реализации, а не языка, независимые реализации, такие как, например JRuby и Rubinius его
не имеют; не исключено, что и будущие версии «эталонного» Ruby изменят свое поведение.</p>

<p>Оптимальный сценарий использования — распараллеливание ожидания: работа с сетью, фоновые действия когда один из потоков ждет
и обрабатывает общение с пользователем, файловые операции. Основным средством взаимодействия между потоками является
использование общих переменных (не забывая про синхронизацию).</p>

<p>При запуске нескольких <em>процессов</em> получаем полный паралеллизм, а вот средства коммуникации приходится прописывать отдельно.</p>

<p>Соответственно, лучше всего такой сценарий поведет себя на максимально независимых задачах, малосвязных, обмен данными между
которыми можно свести к нескольким точкам. Взаимодействие строится на каналах ввода-вывода для дочерних процессов
и сокетах/dRuby для независимых.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:gist">
      <p>Полные тексты примеров находятся по адресу <a href="https://gist.github.com/shikhalev/9198544">https://gist.github.com/shikhalev/9198544</a>. <a href="#fnref:gist" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:context">
      <p>О блоках и замыканиях см. статью <a href="/2015/04/ruby-context.html">«Блоки и контекст в Ruby»</a> в номере 1-2 этого года. <a href="#fnref:context" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:stdlib">
      <p>Подробную документацию на стандартную библиотеку можно найти по адресу <a href="http://rubydoc.info/stdlib/">http://rubydoc.info/stdlib/</a> (англ.) <a href="#fnref:stdlib" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:druby">
      <p><a href="/2015/03/druby.html">«Распределенный Ruby»</a> в декабрьском номере 2013 года. <a href="#fnref:druby" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

</div>

<aside class="recommendations"><div class="random-item">
        <dl>
          <dt>
            <span class="meta">2013.07.21 |</span>
            <a href="/2013/07/git-server.html" title="Настраиваем git-сервер для малых групп с минимальными затратами.">Кратко: примитивный git-сервер</a>
          </dt>
          <dd class="meta">​<a class="fa-icon-laptop-code" href="/tech/" title="Цифровой мир, как он есть, и немного, каким должен быть">Технологии</a>​<a class="fa-icon-icons" href="/tech/soft/" title="Программы, приложения, софт, ПО...">Софт</a>​<a class="fa-icon-keyboard" href="/tech/programming/" title="Языки программирования, алгоритмы, фреймворки, библиотеки и тому подобное">Программирование</a>
</dd>
        </dl>
      </div>
<div class="random-item">
        <dl>
          <dt>
            <span class="meta">2023.01.07 |</span>
            <a href="/2023/01/evil-ai.html" title="Искусственный интеллект в руках естественного идиота">Паникуем иначе</a>
          </dt>
          <dd class="meta">​<a class="fa-icon-laptop-code" href="/tech/" title="Цифровой мир, как он есть, и немного, каким должен быть">Технологии</a>​<a class="fa-icon-keyboard" href="/tech/programming/" title="Языки программирования, алгоритмы, фреймворки, библиотеки и тому подобное">Программирование</a>​<a class="fa-icon-newspaper" href="/life/" title="О жизни, обществе и всяком прочем — просто блог">Жизнь</a>​<a class="fa-icon-users" href="/life/social/" title="Заметки на общественные темы">Общество</a>
</dd>
        </dl>
      </div>
<div class="random-item">
        <dl>
          <dt>
            <span class="meta">2013.04.26 |</span>
            <a href="/2013/04/tdd.html" title="TDD — выдаем нужду за добродетель. Убедительно.">Слоган</a>
          </dt>
          <dd class="meta">​<a class="fa-icon-laptop-code" href="/tech/" title="Цифровой мир, как он есть, и немного, каким должен быть">Технологии</a>​<a class="fa-icon-keyboard" href="/tech/programming/" title="Языки программирования, алгоритмы, фреймворки, библиотеки и тому подобное">Программирование</a>​<a class="fa-icon-biohazard" href="/tech/programming/abs/" title="Абстрактные размышления о программировании в целом">Абстракции</a>​<a class="fa-icon-brain" href="/life/psi/mind/" title="Заметки о том, как мы думаем">Мышление</a>
</dd>
        </dl>
      </div></aside>

<script src="https://giscus.app/client.js" data-repo="shikhalev/shikhalev.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMjI2NTAyNDI=" data-category="General" data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMTgzNDIw" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="ru" crossorigin="anonymous" async>
</script>




</article>

</main><aside id="search">
<script async src="https://cse.google.com/cse.js?cx=757997bbb3ada06b9"></script>
<div class="gcse-search"></div>

</aside><aside id="toc" class="toc toc-post">
  <h4>Содержание</h4>
  <ul id="toc_list" class="section-nav">
<li class="toc-entry toc-h2"><a href="#многопоточность">Многопоточность</a>
<ul>
<li class="toc-entry toc-h3"><a href="#обмен-данными-между-потоками">Обмен данными между потоками</a></li>
<li class="toc-entry toc-h3"><a href="#отступление-о-волокнах">Отступление о «волокнах»</a></li>
<li class="toc-entry toc-h3"><a href="#дополнительно-о-потоках">Дополнительно о потоках</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#процессы-в-ruby">Процессы в Ruby</a>
<ul>
<li class="toc-entry toc-h3"><a href="#сигналы">Сигналы</a></li>
<li class="toc-entry toc-h3"><a href="#каналы-ввода-вывода">Каналы ввода-вывода</a></li>
<li class="toc-entry toc-h3"><a href="#сокеты">Сокеты</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#применение">Применение</a></li>
</ul>
</aside><aside id="backs" style="visibility:hidden;height:0px;width:0px;margin:0px;padding:0px;"></aside><aside id="donate"><iframe loading="lazy" src="https://yoomoney.ru/quickpay/shop-widget?writer=seller&targets=%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0%20%D1%81%D0%B0%D0%B9%D1%82%D0%B0&targets-hint=&default-sum=314&button-text=14&comment=on&hint=%D1%82%D0%B5%D0%BC%D1%8B%20%D0%B4%D0%BB%D1%8F%20%D0%BF%D0%BE%D1%81%D1%82%D0%BE%D0%B2%20%D0%B7%D0%B0%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BF%D1%80%D0%BE%D1%87%D0%B5%D0%B5&successURL=https%3A%2F%2Fshikhalev.org%2F&quickpay=shop&account=410012630934713" width="100%" height="323" frameborder="0" allowtransparency="true" scrolling="no"></iframe>

</aside><!-- скрываем через style, чтоб не менять макет полностью -->
<aside id="ga" style="visibility:hidden;height:0px;width:0px;margin:0px;padding:0px;"></aside><aside id="feeds"><h4>Atom Feeds</h4>
<ul>
  <li>
    <a href="/feed.xml" title="Иван Шихалев">Все записи</a>
    <ul><li><a href="/feed/tech.xml" title="Цифровой мир, как он есть, и немного, каким должен быть">Технологии</a></li><li><a href="/feed/pub.xml" title="Публикации в СМИ">Публикации</a></li></ul>
  </li>
</ul>
</aside><aside id="contacts"><h4>О себе</h4>

<ul>
  <li class="fa-icon-li-id-card person"><a href="/about/">Иван Шихалев</a></li>
  <li class="fa-icon-li-envelope"><a href="mailto:shikhalev@gmail.com">shikhalev@gmail.com</a></li>
  <li class="fa-icon-li-keyboard">Программист</li>
  <li class="fa-icon-li-map-marked-alt">Живу на Урале</li>
  <li class="fa-icon-li-camera">Хобби — фотография</li>
</ul>

<p class="social">
  <a href="https://www.twitter.com/shikhalev" title="Twitter">&#xf099;</a>
  <a href="https://www.facebook.com/shikhalev" title="Facebook">&#xf39e;</a>
  <a href="https://vk.com/shikhalev" title="VK">&#xf189;</a>
  <a href="https://github.com/shikhalev" title="GitHub">&#xf09b;</a>
  <a href="https://instagram.com/ivanshikhalev" title="Instagram">&#xf16d;</a>
  <a href="https://www.linkedin.com/in/shikhalev" title="LinkedIn">&#xf08c;</a>
</p>
</aside><aside id="sidebar" style="border:none;box-shadow:none;"></aside><footer id="site-footer"><!-- Yandex.Metrika informer -->
<a href="https://metrika.yandex.ru/stat/?id=72960469&amp;from=informer"
target="_blank" rel="nofollow"><img src="https://metrika-informer.com/informer/72960469/3_0_FFFFFFFF_EFEFEFFF_0_pageviews"
style="width:88px; height:31px; border:0;float:right;" alt="Яндекс.Метрика" title="Яндекс.Метрика: данные за сегодня (просмотры, визиты и уникальные посетители)" class="ym-advanced-informer" data-cid="72960469" data-lang="ru" /></a>
<!-- /Yandex.Metrika informer -->

<p style="font-weight: bold;">© 1993–2025 <a href="/about/">Иван Шихалев</a></p>

<p>Материалы сайта опубликованы под лицензией
<a style="font-weight: bold;" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>,
если не оговорено иное. <a href="https://github.com/shikhalev/jekyll-theme">Программный код</a> непосредственно сайта — под лицензией
<a style="font-weight: bold;" href="https://opensource.org/licenses/MIT">MIT</a>.</p>

<p>Сайт сформирован статическим генератором <a style="font-weight: bold;" href="https://jekyllrb.com/">Jekyll</a>, комментарии —
<a style="font-weight: bold;" href="https://staticman.net/">Staticman</a>. Отдельная благодарность автору <a style="font-weight: bold;" href="https://github.com/allejo/jekyll-toc">allejo/jekyll-toc</a>.</p>
</footer>

<div id="hl"></div>
<div id="hr"></div>
<div id="hb"></div>
<div id="fl"></div>
<div id="fr"></div>

</div> <!-- #grid -->

<div id="topper" title="Вернуться наверх страницы"><span class="fas">&#xf35b;</span></div>
<script async src="/assets/js/topper.js"></script>

</div> <!-- #global-box -->

</body>

</html>
