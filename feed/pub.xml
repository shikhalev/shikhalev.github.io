<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://shikhalev.github.io/feed/pub.xml" rel="self" type="application/atom+xml" /><link href="https://shikhalev.github.io/" rel="alternate" type="text/html" hreflang="ru" /><updated>2025-06-19T09:01:25+00:00</updated><id>https://shikhalev.github.io/feed/pub.xml</id><title type="html">Иван Шихалев | Pub</title><subtitle>Блог. Склад текстов. И прочее городу и миру...</subtitle><author><name>Иван Шихалев</name></author><entry><title type="html">Rack — основа веб-фреймворков в Ruby</title><link href="https://shikhalev.github.io/2020/01/rack.html" rel="alternate" type="text/html" title="Rack — основа веб-фреймворков в Ruby" /><published>2020-01-11T00:00:00+00:00</published><updated>2020-01-11T00:00:00+00:00</updated><id>https://shikhalev.github.io/2020/01/rack</id><content type="html" xml:base="https://shikhalev.github.io/2020/01/rack.html"><![CDATA[<p><a href="http://samag.ru/archive/article/2952" title="«Системный администратор» №5 (150) за май 2015">Оригинал этой статьи опубликован в журнале «Системный администратор» №5 (150) за май 2015</a>.
Прошу обратить внимание на год — какие-то моменты могут расходиться с современными версиями языка
и библиотек…</p>

<hr />

<figure class="__figure __implicit_figure __right" style="max-width:158px;padding: 5px;"><a href="http://samag.ru/archive/article/2952"><img src="/img/2020/01/11/rack/150-158.webp" class="__image" /></a></figure>

<div class="note">
  <p><strong>Библиотека Rack — простой объектный интерфейс для написания веб-приложений.</strong></p>

  <p>Слово «rack» в английском языке имеет множество значений, включая такие, как «пытка» и «разрушение»…
Однако, надо полагать, название рассматриваемой библиотеки произошло от другой группы смыслов: «стойка»,
«штатив», «каркас» и т.д. Rack обеспечивает простой и в то же время удобный интерфейс, обеспечивающий
взаимодействие между веб-сервером и приложением, позволяя программисту сосредоточиться исключительно
на логике последнего.</p>

  <p>Этот интерфейс достаточно низкоуровневый и не ограничивает разработчика каким-либо заранее заданным
способом организации приложения и высокоуровневыми абстракциями. Соответственно, он и не предоставляет
таких абстракций — это уже дело фреймворков, которые работают поверх него: Rails, Sinatra и других.</p>
</div>

<!--more-->

<h2 id="зачем-знать-rack">Зачем знать Rack?</h2>

<p>Практически вся веб-разработка на Ruby использует Rack, как правило — посредством того или иного более
высокоуровневого фреймворка. Но это не обязательно, задачи бывают разные: для каких-то те же Rails
слишком тяжеловесны, для каких-то — слишком «заточены» под определенное использование и структуру программы.</p>

<p>Можно выделить три цели изучения именно Rack как такового:</p>

<ul>
  <li>Понимание того, что находится у популярных фреймворков «под капотом», чтобы ориентироваться в более-менее
сложных случаях, не предусмотренных их создателями.</li>
  <li>Написание небольших веб-приложений для простых задач, когда использование чего-то более тяжелого будет
напрасной тратой ресурсов.</li>
  <li>Разработка сложных и необычных веб-приложений, которые не вписываются в идеологию и структуру существующих
фреймворков. MVC<sup id="fnref:mvc"><a href="#fn:mvc" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> — хорошая и проверенная временем концепция, но все же не панацея и не «серебряная пуля».</li>
</ul>

<h2 id="как-это-работает">Как это работает</h2>

<p>Для начала установим соответствующий гем:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>gem <span class="nb">install </span>rack
<span class="go">Fetching: rack-1.6.0.gem (100%)
Successfully installed rack-1.6.0
1 gem installed</span></code></pre>
</figure>

<p>Установить можно было бы и без <code class="language-plaintext highlighter-rouge">sudo</code>, т.е. только для локального пользователя. Но в этом случае мы не сможем
использовать предоставляемые гемом исполняемые файлы, без которых обойтись можно, но не хочется.</p>

<p>Простейшее веб-приложение может выглядеть, например, так<sup id="fnref:gist"><a href="#fn:gist" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'pp'</span>
<span class="nb">require</span> <span class="s1">'rack'</span>

<span class="n">app</span> <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span>
  <span class="p">[</span>
    <span class="mi">200</span><span class="p">,</span>
    <span class="p">{</span> <span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/plain'</span> <span class="p">},</span>
    <span class="p">[</span> <span class="n">env</span><span class="p">.</span><span class="nf">pretty_inspect</span> <span class="p">]</span>
  <span class="p">]</span>
<span class="k">end</span>

<span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">WEBrick</span><span class="p">.</span><span class="nf">run</span> <span class="n">app</span></code></pre>
</figure>

<p>Запускаем:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo01.rb
<span class="go">[2015-03-24 14:07:11] INFO  WEBrick 1.3.1
[2015-03-24 14:07:11] INFO  ruby 2.1.5 (2014-11-13) [x86_64-linux]
[2015-03-24 14:07:11] INFO  WEBrick::HTTPServer♯start: pid=6883 port=8080</span></code></pre>
</figure>

<p>И теперь мы можем, зайдя браузером по адресу <a href="http://localhost:8080/">http://localhost:8080/</a>, видеть список HTTP-заголовков и переменных
сервера в виде объекта класса <code class="language-plaintext highlighter-rouge">Hash</code>. 8080 здесь — порт по умолчанию, он используется если при вызове <code class="language-plaintext highlighter-rouge">run</code> не указан
какой-либо другой.</p>

<p>Как можно видеть из кода выше, основная рабочая часть у нас — это <code class="language-plaintext highlighter-rouge">Proc</code>-объект, который получает на вход хэш
с переменными, и возвращает специальным образом определенный массив. Поскольку в Ruby принято использовать
«утиную» типизацию, класс объекта на самом деле не важен, важен метод <code class="language-plaintext highlighter-rouge">call</code>, принимающий хэш и возвращающий
соответствующий массив.</p>

<p>Массив должен содержать три элемента: код ответа (в нашем случае — «200 OK»<sup id="fnref:httpcodes"><a href="#fn:httpcodes" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>), HTTP-заголовки ответа
в виде хэша и тело ответа в виде массива (точнее опять же произвольного объекта, позволяющего последовательный
перебор элементов), содержащего строки.</p>

<p>Итак, наше приложение, т.е. объект с методом <code class="language-plaintext highlighter-rouge">call</code>, запускается неким обработчиком, в данном случае — <code class="language-plaintext highlighter-rouge">WEBrick</code>,
который определяет используемый сервер. Серверы могут быть разными, каждый имеет свои преимущества и недостатки,
причем для серьезной работы под реальной нагрузкой <code class="language-plaintext highlighter-rouge">WEBrick</code>, вероятно, хуже всех, однако только он входит
в стандартную библиотеку Ruby, соответственно его не придется отдельно устанавливать в большинстве случаев.</p>

<p>Останавливается сервер нажатием <code class="language-plaintext highlighter-rouge">Ctrl+C</code> в консоли, где он запущен (в некоторых случаях, в зависимости от версий ПО
и системного окружения, может потребоваться <code class="language-plaintext highlighter-rouge">Ctrl+Alt+C</code>). Это корректный способ прерывания работы, высвобождающий
системные ресурсы (такие, например, как занятый порт), хотя, конечно, в реальных проектах следует предусмотреть
альтернативный способ останова/перезапуска, чтобы выполнить какие-то дополнительные действия — сохранить данные, например.</p>

<p>Разобравшись с простым примером, рассмотрим его же, но немного иначе запущенный. Нам понадобится файл с расширением
<code class="language-plaintext highlighter-rouge">.ru</code> следующего содержания:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'pp'</span>

<span class="n">app</span> <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span>
  <span class="p">[</span>
    <span class="mi">200</span><span class="p">,</span>
    <span class="p">{</span> <span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/plain'</span> <span class="p">},</span>
    <span class="p">[</span> <span class="n">env</span><span class="p">.</span><span class="nf">pretty_inspect</span> <span class="p">]</span>
  <span class="p">]</span>
<span class="k">end</span>

<span class="n">run</span> <span class="n">app</span></code></pre>
</figure>

<p>Воспользуемся утилитой <code class="language-plaintext highlighter-rouge">rackup</code>:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>rackup demo01.ru
<span class="go">[2015-03-24 15:04:08] INFO  WEBrick 1.3.1
[2015-03-24 15:04:08] INFO  ruby 2.1.5 (2014-11-13) [x86_64-linux]
[2015-03-24 15:04:08] INFO  WEBrick::HTTPServer♯start: pid=12753 port=9292</span></code></pre>
</figure>

<p>Изменился порт по умолчанию, не требуется явное указание «<code class="language-plaintext highlighter-rouge">require 'rack'</code>», и, что гораздо интереснее, наш исходный
код абстрагировался от выбора сервера. Его при использовании <code class="language-plaintext highlighter-rouge">rackup</code> тоже можно указать в явном виде, но уже
в параметрах командной строки (как и номер порта).</p>

<p>В целом, <code class="language-plaintext highlighter-rouge">rackup</code> продолжает доброе дело абстрагирования разработчика от каких-то вещей, которые должны быть скорее
в ведении администратора.</p>

<h2 id="rackrequest-и-разбор-параметров">Rack::Request и разбор параметров</h2>

<p>Данные запроса приходят в параметре <code class="language-plaintext highlighter-rouge">env</code> в виде текстовых строк, как они собственно и определены протоколом HTTP.
Однако некоторые из них на самом деле имеют свою внутреннюю структуру и для нормальной работы их еще предстоит
распарсить. Можно, конечно, это каждый раз делать вручную, но Rack предоставляет более удобный вариант — класс <code class="language-plaintext highlighter-rouge">Rack::Request</code>.
Так, мы можем получить параметры в виде хэша — заменим нашу процедуру (в новом <code class="language-plaintext highlighter-rouge">.ru</code>-файле) на такую:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">app</span> <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span>
  <span class="n">req</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span> <span class="n">env</span>
  <span class="p">[</span>
    <span class="mi">200</span><span class="p">,</span>
    <span class="p">{</span> <span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/plain'</span> <span class="p">},</span>
    <span class="p">[</span> <span class="n">req</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">pretty_inspect</span> <span class="p">]</span>
  <span class="p">]</span>
<span class="k">end</span></code></pre>
</figure>

<p>Запустим приложение:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>rackup demo02.ru</code></pre>
</figure>

<p>И обратимся, например, по адресу <a href="http://localhost:9292/?alpha=beta&amp;gamma=delta">http://localhost:9292/?alpha=beta&amp;gamma=delta</a>. В браузере мы увидим:</p>

<figure class="highlight">
  <pre><code class="language-text" data-lang="text">{"alpha"=&gt;"beta", "gamma"=&gt;"delta"}</code></pre>
</figure>

<p>Вместо строковой переменной из <code class="language-plaintext highlighter-rouge">demo01.ru</code>:</p>

<figure class="highlight">
  <pre><code class="language-text" data-lang="text">{. . .,
 "QUERY_STRING"=&gt;"alpha=beta&amp;gamma=delta",
 . . .}</code></pre>
</figure>

<p>Аналогично в удобном структурированном виде представлены и куки.</p>

<p>Кроме того, состав переменных в хэше <code class="language-plaintext highlighter-rouge">env</code> зависит от выбранного сервера, отличия небольшие, но учитывать
их придется, и лучше пусть это сделает за нас <code class="language-plaintext highlighter-rouge">Rack::Request</code>, методы которого всегда выдают одну и ту же
информацию<sup id="fnref:request"><a href="#fn:request" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p>

<p>Для формирования ответа тоже есть специальный класс — <code class="language-plaintext highlighter-rouge">Rack::Response</code><sup id="fnref:response"><a href="#fn:response" class="footnote" rel="footnote" role="doc-noteref">5</a></sup>.</p>

<p>С его помощью пример можно переписать так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">app</span> <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span>
  <span class="n">req</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span> <span class="n">env</span>
  <span class="n">res</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Response</span><span class="p">.</span><span class="nf">new</span>
  <span class="n">res</span><span class="p">[</span><span class="s1">'Content-Type'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'text/plain'</span>
  <span class="n">res</span><span class="p">.</span><span class="nf">write</span> <span class="n">req</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">pretty_inspect</span>
  <span class="n">res</span><span class="p">.</span><span class="nf">finish</span>
<span class="k">end</span></code></pre>
</figure>

<p>Важно не забыть про метод <code class="language-plaintext highlighter-rouge">finish</code>, который собственно и формирует необходимый ответ.</p>

<h2 id="декомпозиция">Декомпозиция</h2>

<p>Очевидно, более-менее сложное приложение в одной процедуре или методе не поместится. Поэтому, как правило,
приложение все-таки представляет собой отдельный объект (модуль/класс), в котором метод <code class="language-plaintext highlighter-rouge">call</code> обращается
к более специфическим методам. Но это — процедурная декомпозиция, подходящая для разных действий одного объекта.
Если наше приложение содержит логически различные части, имеет смысл вынести эту логику в разные объекты.
И здесь Rack предоставляет два механизма декомпозиции — в разных, если можно так выразиться, измерениях.</p>

<p>Во-первых, мы можем назначить разные объекты на разные пути внутри нашего сайта. Например, адреса, начинающиеся
с <code class="language-plaintext highlighter-rouge">/img/</code> будут читать из какого-то каталога на диске файлы изображений и просто отдавать их. А все прочие адреса
уже обрабатываться более сложным образом.</p>

<p>Во-вторых, некоторые действия, такие как, например, проверка пользовательской сессии, нужно производить
при каждом вызове, до основной логики.</p>

<p>Для этих целей используются механизмы роутинга и «прослоек» (middleware в терминологии Rack), предоставляемые
классом <code class="language-plaintext highlighter-rouge">Rack::Builder</code>. Как это выглядит? Примерно так (создадим очередной <code class="language-plaintext highlighter-rouge">.ru</code>-файл):</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Log</span>

  <span class="k">def</span> <span class="nf">initialize</span> <span class="n">app</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="vg">$stderr</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">app</span>
    <span class="vi">@output</span> <span class="o">=</span> <span class="n">output</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span> <span class="n">env</span>
    <span class="vi">@output</span><span class="p">.</span><span class="nf">puts</span> <span class="n">env</span><span class="p">.</span><span class="nf">pretty_inspect</span>
    <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span> <span class="n">env</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">json</span> <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span>
  <span class="p">[</span>
    <span class="mi">200</span><span class="p">,</span>
    <span class="p">{</span> <span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'application/json'</span> <span class="p">},</span>
    <span class="p">[</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">generate</span><span class="p">(</span><span class="n">env</span><span class="p">)</span> <span class="p">]</span>
  <span class="p">]</span>
<span class="k">end</span>

<span class="n">txt</span> <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span>
  <span class="p">[</span>
    <span class="mi">200</span><span class="p">,</span>
    <span class="p">{</span> <span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/plain'</span> <span class="p">},</span>
    <span class="p">[</span> <span class="n">env</span><span class="p">.</span><span class="nf">pretty_inspect</span> <span class="p">]</span>
  <span class="p">]</span>
<span class="k">end</span>

<span class="n">app</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">app</span> <span class="k">do</span>

  <span class="n">use</span> <span class="no">Log</span>

  <span class="n">map</span> <span class="s1">'/js/'</span> <span class="k">do</span>
    <span class="n">run</span> <span class="n">json</span>
  <span class="k">end</span>

  <span class="n">run</span> <span class="n">txt</span>

<span class="k">end</span>

<span class="n">run</span> <span class="n">app</span></code></pre>
</figure>

<p>Здесь класс <code class="language-plaintext highlighter-rouge">Log</code> — та самая прослойка, которая будет вызываться при любом запросе страницы. А приложений — два:
одно генерирует JSON-представление, а другое, как и раньше простой текст. Как видим, прослойка подключается методом
<code class="language-plaintext highlighter-rouge">use</code>, а приложение для определенного пути — в блоке метода <code class="language-plaintext highlighter-rouge">map</code>. Кстати, внутри этого блока можно добавлять
и отдельные прослойки, если они нужны только там, а не глобально.</p>

<p>В результате вызова <code class="language-plaintext highlighter-rouge">Rack::Builder.app</code> мы получаем комбинированное rack-приложение, которое и запускаем последней строчкой.</p>

<p>На самом деле, в <code class="language-plaintext highlighter-rouge">.ru</code>-файле такое описание избыточно, поскольку его содержимое запускается утилитой <code class="language-plaintext highlighter-rouge">rackup</code> уже внутри блока
<code class="language-plaintext highlighter-rouge">Rack::Bilder</code>, т.е. мы могли бы написать и просто:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">use</span> <span class="no">Log</span>

<span class="n">map</span> <span class="s1">'/js/'</span> <span class="k">do</span>
  <span class="n">run</span> <span class="n">json</span>
<span class="k">end</span>

<span class="n">run</span> <span class="n">txt</span></code></pre>
</figure>

<h2 id="штатные-дополнения">Штатные дополнения</h2>

<p>Некоторые задачи при создании веб-приложений встречаются регулярно — практически всегда требуется вести какое-то логирование,
отдавать статические файлы и так далее. Гем <code class="language-plaintext highlighter-rouge">rack</code> содержит ряд классов для решения таких типовых задач, я не буду на них
подробно останавливаться<sup id="fnref:gem"><a href="#fn:gem" class="footnote" rel="footnote" role="doc-noteref">6</a></sup>, лишь перечислю основные.</p>

<p>Приложения:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Rack::File</code> отдает статические файлы по заранее заданному пути.</li>
  <li><code class="language-plaintext highlighter-rouge">Rack::Directory</code> выводит содержимое каталогов и отдает файлы посредством <code class="language-plaintext highlighter-rouge">Rack::File</code>.</li>
</ul>

<p>Прослойки:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Rack::Auth::Basic</code> и <code class="language-plaintext highlighter-rouge">Rack::Auth::Digest</code> предоставляют простую стандартную HTTP-аутентификацию.</li>
  <li><code class="language-plaintext highlighter-rouge">Rack::Logger</code> и <code class="language-plaintext highlighter-rouge">Rack::CommonLogger</code> обеспечивают логирование.</li>
  <li><code class="language-plaintext highlighter-rouge">Rack::ConditionalGet</code> и <code class="language-plaintext highlighter-rouge">Rack::ETag</code> позволяют уменьшить отдаваемый трафик, управляя заголовками кэширования. К сожалению,
они работают с уже сформированным ответом, поэтому экономии вычислительных ресурсов сервера не получится.</li>
  <li><code class="language-plaintext highlighter-rouge">Rack::ContentLength</code> устанавливает автоматически соответствующий заголовок.</li>
  <li><code class="language-plaintext highlighter-rouge">Rack::Deflate</code> — сжимает передаваемые данные, автоматически определяя, когда это можно и нужно делать.</li>
  <li>Модуль <code class="language-plaintext highlighter-rouge">Rack::Session</code> и определенные внутри него классы <code class="language-plaintext highlighter-rouge">Cookie</code>, <code class="language-plaintext highlighter-rouge">Memcache</code> и <code class="language-plaintext highlighter-rouge">Pool</code> обеспечивают управление сессиями.</li>
  <li><code class="language-plaintext highlighter-rouge">Rack::Static</code> отдает статические файлы по заранее определенным правилам.</li>
</ul>

<p>Эти классы и модули решают типовые задачи типовыми и довольно таки прямолинейными методами, каких-то чудес от них ждать не стоит.
Зато работают, что называется, «из коробки».</p>

<p>Дополнительно стоит упомянуть о модулях <code class="language-plaintext highlighter-rouge">Rack::Mime</code> и <code class="language-plaintext highlighter-rouge">Rack::Utils</code>, которые предоставляют различные вспомогательные средства
для веб-разработки.</p>

<h2 id="итого">Итого</h2>

<p>Rack представляет собой очень простой объектный интерфейс для взаимодействия с веб-сервером, с одной стороны — абстрагируя
разработчика от мелких деталей, с другой — не навязывая какой-то определенной архитектуры приложения. Стоит ли его использовать
<em>вместо фрейморков</em> — зависит от задачи и личной склонности программиста. Не надо только забывать, что это «голый каркас»,
и большинство даже типовых задач придется решать «с нуля», тогда как в Ruby on Rails, например, они уже решены.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:mvc">
      <p>Model-View-Controller — широко распространенный шаблон проектирования приложений. <a href="#fnref:mvc" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:gist">
      <p>Полные тексты примеров размещены на GitHub — <a href="https://gist.github.com/shikhalev/8409eef4a4e66a003670">https://gist.github.com/shikhalev/8409eef4a4e66a003670</a>. <a href="#fnref:gist" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:httpcodes">
      <p>См. коды ответов, например, в Википедии — <a href="https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP">https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP</a>. <a href="#fnref:httpcodes" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:request">
      <p>Список методов см. в документации — <a href="https://www.rubydoc.info/gems/rack/Rack/Request">https://www.rubydoc.info/gems/rack/Rack/Request</a>. <a href="#fnref:request" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:response">
      <p><a href="https://www.rubydoc.info/gems/rack/Rack/Response">https://www.rubydoc.info/gems/rack/Rack/Response</a>. <a href="#fnref:response" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:gem">
      <p>За подробностями стоит обратиться к документации — <a href="http://www.rubydoc.info/gems/rack/">http://www.rubydoc.info/gems/rack/</a>. <a href="#fnref:gem" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Иван Шихалев</name></author><category term="[&quot;tech&quot;, &quot;programming&quot;, &quot;ruby&quot;, &quot;pub&quot;, &quot;samag&quot;, &quot;web&quot;]" /><category term="Rack" /><summary type="html"><![CDATA[Библиотека Rack — простой объектный интерфейс для написания веб-приложений (статья в журнале «Системный администратор»)]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://shikhalev.github.io/img/2020/01/11/rack/screen-rack-640x640-500-261-0-0.webp" /><media:content medium="image" url="https://shikhalev.github.io/img/2020/01/11/rack/screen-rack-640x640-500-261-0-0.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Средства самопознания в Ruby</title><link href="https://shikhalev.github.io/2016/03/introspection.html" rel="alternate" type="text/html" title="Средства самопознания в Ruby" /><published>2016-03-09T00:00:00+00:00</published><updated>2016-03-09T00:00:00+00:00</updated><id>https://shikhalev.github.io/2016/03/introspection</id><content type="html" xml:base="https://shikhalev.github.io/2016/03/introspection.html"><![CDATA[<p><a href="http://samag.ru/archive/article/2874">Оригинал этой статьи опубликован в журнале «Системный администратор» №1-2 (146-147) за февраль 2015</a>.</p>

<hr />

<figure class="__figure __implicit_figure __right" style="max-width:158px;padding: 5px;"><a href="http://samag.ru/archive/article/2874"><img src="/img/2016/03/09/introspection/146-7-158.webp" class="__image" /></a></figure>

<div class="note">

  <p><strong>Что программа может знать о самой себе?</strong></p>

  <p>Практически все современные языки программирования содержат средства, позволяющие во время выполнения программы
получить какие-то данные о структуре самой этой программы. В компилируемых языках такие возможности, как правило,
ограничены и отключаемы, в целях оптимизации, в интерпретируемых же более обширны, поскольку эти данные все равно
необходимы самому интерпретатору, соответственно, содержатся в памяти, и вопрос только в том, предоставлять ли
к ним доступ языковыми средствами.</p>

  <p>В данной статье я планирую рассмотреть те средства «самопознания», которые доступны для программ на Ruby.</p>
</div>

<!--more-->

<p>Возвращаясь к компилируемым языкам: в них существует четкое разделение — есть <em>отладочная информация</em>, которая самой
программе недоступна, и есть <em>RTTI (Run-Time Type Information)</em> — первая включается только для отладки, вторая может
использоваться в нормальной логике программы, если есть такая потребность (в первую очередь это полезно для написания
гибко строящихся программ из «кирпичиков» — компонентов, которые могут добавляться/подгружаться и во время выполнения
тоже). Такое функциональное деление удобно и для интерпретируемых языков, в которых, правда, к этим двум категориям
можно добавить еще одну — состояние интерпретатора / виртуальной машины в целом.</p>

<h2 id="отладочная-информация-доступная-программе">Отладочная информация, доступная программе</h2>

<p>Начнем с самого простого: специальные методы <code class="language-plaintext highlighter-rouge">__FILE__</code> и <code class="language-plaintext highlighter-rouge">__LINE__</code> позволят определить и, скажем, вывести текущую
точку исполнения программы. Например, для логирования.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">log</span> <span class="n">msg</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span>
  <span class="vg">$stderr</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"[</span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="n">line</span><span class="si">}</span><span class="s2">] </span><span class="si">#{</span><span class="n">msg</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">log</span> <span class="s1">'Сообщение'</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span></code></pre>
</figure>

<p>Запустив пример, получим что-то вроде:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby intro01.rb
<span class="go">[intro01.rb:7] Сообщение</span></code></pre>
</figure>

<p>Почему 7, а не 5? В файле примера<sup id="fnref:gist"><a href="#fn:gist" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> присутствует еще две строки: первая — специальный комментарий с указанием кодировки,
вторая для отступа. Внутри статей я подобные повторяемые везде вещи опускаю.</p>

<p>Конечно, в момент написания кода с <code class="language-plaintext highlighter-rouge">__FILE__</code> и <code class="language-plaintext highlighter-rouge">__LINE__</code> мы и так знаем, в каком файле и на какой строке находимся,
но при дальнейшем редактировании эта строчка кода может оказаться где угодно.</p>

<p>Однако было бы здорово, если б наш метод логирования как-то сам узнавал, откуда был вызван, без лишних параметров.
И это вполне возможно — рассмотрим следующий пример.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">log</span> <span class="n">msg</span>
  <span class="vg">$stderr</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"[</span><span class="si">#{</span><span class="nb">caller</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">] </span><span class="si">#{</span><span class="n">msg</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">log2</span> <span class="n">msg</span>
  <span class="n">cl</span> <span class="o">=</span> <span class="n">caller_locations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="vg">$stderr</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"[</span><span class="si">#{</span><span class="n">cl</span><span class="p">.</span><span class="nf">path</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="n">cl</span><span class="p">.</span><span class="nf">lineno</span><span class="si">}</span><span class="s2">] </span><span class="si">#{</span><span class="n">msg</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">log</span> <span class="s1">'Сообщение'</span>

<span class="n">log2</span> <span class="s1">'Сообщение'</span></code></pre>
</figure>

<p>Запустив его мы получим следующее:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby intro02.rb
<span class="go">[intro02.rb:12:in `‹main›'] Сообщение
[intro02.rb:14] Сообщение</span></code></pre>
</figure>

<p>Замечательные методы <code class="language-plaintext highlighter-rouge">caller</code> и <code class="language-plaintext highlighter-rouge">caller_locations</code> предоставляют нам весь стек вызовов в виде строк и специальных объектов
класса <code class="language-plaintext highlighter-rouge">Thread::Backtrace::Location</code> соответственно. Второй вариант дает более гибкие возможности, но надо помнить, что он
стал доступен только начиная с версии Ruby 2.0<sup id="fnref:vers"><a href="#fn:vers" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.</p>

<p>Еще одно традиционное использование <code class="language-plaintext highlighter-rouge">caller</code> — при генерации исключений: очень часто исключения генерируются сразу после
входа в метод, при проверке переданных параметров. И нас в этом случае не особо-то интересует место в программе, где эта
проверка производится — гораздо удобней сразу указать на то место, откуда был вызыван метод, и где, соответственно, были
заданы неверные параметры.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">divide</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
  <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">b</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="k">raise</span> <span class="no">StandardError</span><span class="p">,</span> <span class="s1">'На ноль делить нельзя'</span><span class="p">,</span> <span class="nb">caller</span>
  <span class="k">end</span>
  <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></code></pre>
</figure>

<p>Получаем:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby intro02a.rb
<span class="go">intro02a.rb:10:in `‹main›': На ноль делить нельзя (StandardError)</span></code></pre>
</figure>

<p>Если мы закомментируем «<code class="language-plaintext highlighter-rouge">, caller</code>», то получим более длинный вывод:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby intro02a.rb
<span class="go">intro02a.rb:5:in `divide': На ноль делить нельзя (StandardError)
        from intro02a.rb:10:in `‹main›'</span></code></pre>
</figure>

<p>Но все полезное, что мы могли бы узнать изучив пятую строку и ее окружение, уже известно из сообщения…</p>

<p>В общем, такая генерация ошибок принята, если исключение бросается непосредственно по итогам проверки параметров,
и не принята в других случаях, когда внутренняя логика метода, где произошло исключение, важна для понимания его причин.</p>

<h2 id="rtti">RTTI</h2>

<p>Во-первых, для любого объекта Ruby мы можем получить его класс и список методов. Во-вторых, классы и модули также дают
информацию о методах, определяемых в них, а кроме того, и о константах. И в-третьих, зная объект (класс) и имя метода,
мы можем получить более подробную информацию, включая список параметров и место, где метод был определен.</p>

<p>Итак, по порядку: чтобы узнать класс, мы можем воспользоваться методами <code class="language-plaintext highlighter-rouge">obj.class</code> или <code class="language-plaintext highlighter-rouge">singleton_class</code>. Я не случайно
написал в первом случае <code class="language-plaintext highlighter-rouge">obj.class</code> через точку, поскольку даже находясь в контексте объекта<sup id="fnref:context"><a href="#fn:context" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>, без точки вызвать
мы его не можем — это будет воспринято интерпретатором как ключевое слово <code class="language-plaintext highlighter-rouge">class</code>. <code class="language-plaintext highlighter-rouge">singleton_class</code>, т.е. уникальный
класс данного единичного объекта, нам обычно не нужен, если только мы не определяли какие-то уникальные методы для него.</p>

<p>Далее мы можем узнать всю цепочку наследования, в том числе включенные посредством <code class="language-plaintext highlighter-rouge">include</code> или <code class="language-plaintext highlighter-rouge">extend</code> модули.
Для это­го нам понадобится вызов метода <code class="language-plaintext highlighter-rouge">ancestors</code> у <em>класса</em>.</p>

<p>Чтобы получить список имен методов объекта, мы можем воспользоваться следующими методами класса <code class="language-plaintext highlighter-rouge">Object</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">private_methods</code> — вернет массив имен приватных методов;</li>
  <li><code class="language-plaintext highlighter-rouge">protected_methods</code> — «защищенных»;</li>
  <li><code class="language-plaintext highlighter-rouge">public_methods</code> — публичных;</li>
  <li><code class="language-plaintext highlighter-rouge">methods</code> — публичных и защищенных вместе.</li>
</ul>

<p>Разница приватных и «защищенных» методов в том, что первые могут быть вызваны только в контексте того объекта,
для которого они вызываются, тогда как вторые — в контексте любого объекта того же класса.</p>

<p>Дополнительно отмечу <code class="language-plaintext highlighter-rouge">singleton_methods</code>, возвращающий список методов, определенных только для конкретного объекта.</p>

<p>Классы и модули предоставляют также списки <em>методов экземпляров</em>, т.е. тех методов, которые могут быть вызваны для всех
объектов, принадлежащих классу или включающих модуль:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">private_instance_methods</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">protected_instance_methods</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">public_instance_methods</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">instance_methods</code>.</li>
</ul>

<p>Связь между этими методами и описанными выше можно выразить так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">obj</span><span class="p">.</span><span class="nf">xxx_methods</span> <span class="o">==</span> <span class="n">obj</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">.</span><span class="nf">xxx_instance_methods</span></code></pre>
</figure>

<p>Классы и модули (в отличие от объектов) позволяют получит еще и список констант. Для этого служит метод <code class="language-plaintext highlighter-rouge">constants</code>.</p>

<p>Все эти методы принимают один необязательный параметр, указывающий, нужно ли включать унаследованные методы (по умолчанию — <code class="language-plaintext highlighter-rouge">true</code>).</p>

<p>Продемонстрирую вышесказанное на примере:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_module</span> <span class="n">mod</span><span class="p">,</span> <span class="nb">ancestors</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="k">if</span> <span class="nb">ancestors</span>
    <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">mod</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">downcase</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">mod</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">"</span> <span class="o">+</span>
      <span class="s2">" </span><span class="si">#{</span><span class="n">mod</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">else</span>
    <span class="nb">puts</span> <span class="s2">"  </span><span class="si">#{</span><span class="n">mod</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">downcase</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">mod</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="n">mod</span><span class="p">.</span><span class="nf">constants</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"    const </span><span class="si">#{</span><span class="n">c</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="n">mod</span><span class="p">.</span><span class="nf">public_instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"    </span><span class="si">#{</span><span class="n">m</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="k">if</span> <span class="nb">ancestors</span>
    <span class="n">ancs</span> <span class="o">=</span> <span class="n">mod</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">[</span><span class="mi">1</span><span class="o">..-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ancs</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">anc</span><span class="o">|</span>
      <span class="n">print_module</span> <span class="n">anc</span><span class="p">,</span> <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>Запустив пример, мы получим довольно длинный вывод, приведу лишь его начало:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby intro03.rb
<span class="go">class Class [Class, Module, Object, Kernel, BasicObject]
    :allocate
    :new
    :superclass
  class Module
    :freeze
    :===</span></code></pre>
</figure>

<p>Константы в классах <code class="language-plaintext highlighter-rouge">Class</code> и <code class="language-plaintext highlighter-rouge">Module</code> не содержатся, но в далее в выводе они появятся в большом количестве — константы,
которые принято считать глобальными, относятся к классу <code class="language-plaintext highlighter-rouge">Object</code>.</p>

<p>Список имен — это, конечно, хорошо, но мало. Ruby позволяет получить и более подробную информацию о каждом методе. Для этого
нам нужно получить соответствующий объект посредством <code class="language-plaintext highlighter-rouge">method</code> (для любого объекта), или <code class="language-plaintext highlighter-rouge">instance_method</code> (для классов и модулей).
В первом случае мы получим объект класса <code class="language-plaintext highlighter-rouge">Method</code>, а во втором — <code class="language-plaintext highlighter-rouge">UnboudMethod</code>. Разница между ними в том, что первый привязан
к объекту и может быть вызван непосредственно, тогда как второй существует как бы сам по себе и для вызова должен быть
предварительно привязан посредством <code class="language-plaintext highlighter-rouge">bind</code>. Но сейчас для нас это не принципиально, нас итересует информация, которую они
предоставляют, а она одинакова.</p>

<p>Итак, что мы можем получить?</p>

<p>Во-первых, <code class="language-plaintext highlighter-rouge">source_location</code>, т.е. расположение исходников метода. Возвращает массив из двух значений — имя файла и номер строки,
или <code class="language-plaintext highlighter-rouge">nil</code>, если метод определен во внешней библиотеке (Ruby позволяет писать «расширения» — специальные разделяемые библиотеки
на компилируемых языках, в первую очередь, конечно, на C).</p>

<p>Во-вторых, <code class="language-plaintext highlighter-rouge">owner</code> — класс или модуль, в котором данный метод определен.</p>

<p>И в-третьих, самое, пожалуй, интересное — это <code class="language-plaintext highlighter-rouge">parameters</code> — массив, описывающий все параметры метода, как они заданы в его определении.
Возвращаемое значение — массив, в котором каждый параметр представлен массивом же из двух элементов: первый описывает вид параметра —
обязательный, необязательный и т.д., а второй — его имя. Выглядит это примерно так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">test</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">:,</span> <span class="ss">e: </span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:test</span><span class="p">).</span><span class="nf">parameters</span></code></pre>
</figure>

<p>Получим:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby intro04.rb
<span class="go">[[:req, :a], [:opt, :b], [:rest, :c], [:keyreq, :d], [:key, :e], [:keyrest, :f], [:block, :g]]</span></code></pre>
</figure>

<p>Впрочем, если метод определен во внешней библиотеке-расширении, или в ядре языка, то есть опять же в скомпилированном коде,
то Ruby знает о параметрах только их вид, и массивы в списке состоят из одного элемента. Таким образом, например,
<code class="language-plaintext highlighter-rouge">method(:method).parameters</code> вернет <code class="language-plaintext highlighter-rouge">[[:req]]</code>.</p>

<p>Исходя из этого, мы можем написать функцию, восстанавливающую примерный заголовок метода из соответствующего ему объекта.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="no">ARG_TEMPLATE</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">req: </span><span class="s1">'%s'</span><span class="p">,</span>
  <span class="ss">opt: </span><span class="s1">'%s = &lt;..&gt;'</span><span class="p">,</span>
  <span class="ss">rest: </span><span class="s1">'*%s'</span><span class="p">,</span>
  <span class="ss">key: </span><span class="s1">'%s: &lt;..&gt;'</span><span class="p">,</span>
  <span class="ss">keyreq: </span><span class="s1">'%s:'</span><span class="p">,</span>
  <span class="ss">keyrest: </span><span class="s1">'**%s'</span><span class="p">,</span>
  <span class="ss">block: </span><span class="s1">'&amp;%s'</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">header</span> <span class="n">mobj</span>
  <span class="n">anprefix</span> <span class="o">=</span> <span class="s1">'arg'</span>
  <span class="n">ancounter</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">mobj</span><span class="p">.</span><span class="nf">parameters</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">param</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">param</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="mi">2</span>
      <span class="nb">name</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="nb">name</span> <span class="o">=</span> <span class="n">anprefix</span> <span class="o">+</span> <span class="n">ancounter</span><span class="p">.</span><span class="nf">to_s</span>
      <span class="n">ancounter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">end</span>
    <span class="n">params</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="no">ARG_TEMPLATE</span><span class="p">[</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">%</span> <span class="nb">name</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">result</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="n">mobj</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">(</span><span class="si">#{</span><span class="n">params</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span>
  <span class="k">if</span> <span class="n">mobj</span><span class="p">.</span><span class="nf">source_location</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s2">" [</span><span class="si">#{</span><span class="n">mobj</span><span class="p">.</span><span class="nf">source_location</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">':'</span><span class="p">)</span><span class="si">}</span><span class="s2">]"</span>
  <span class="k">else</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s2">" [&lt;binary&gt;]"</span>
  <span class="k">end</span>
  <span class="n">result</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">test</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">:,</span> <span class="ss">e: </span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">header</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:test</span><span class="p">))</span>
<span class="nb">puts</span> <span class="n">header</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:header</span><span class="p">))</span>
<span class="nb">puts</span> <span class="n">header</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:puts</span><span class="p">))</span></code></pre>
</figure>

<p>Запустив этот код, получим:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby intro05.rb
<span class="go">test(a, b = ‹..›, *c, d:, e: ‹..›, **f, &amp;g) [intro05.rb:35]
header(mobj) [intro05.rb:13]
puts(*arg0) [‹binary›]</span></code></pre>
</figure>

<p>К сожалению, конкретные значения, заданные для опциональных параметров по умолчанию, так просто выяснить не получится.
Можно, правда, зная, где данный метод определен, распарсить текст программы, но это уже выходит за рамки нашей темы.</p>

<h2 id="картина-в-целом">Картина в целом</h2>

<p>Итак, мы можем посмотреть методы и константы для любого класса, модуля, да и произвольного объекта (хотя это и редко
может потребоваться). Однако, при этом нам надо откуда-то знать о его существовании вообще. Неплохо было бы иметь
возможность получить список классов и модулей, существующих в программе, и такая возможность есть — метод
<code class="language-plaintext highlighter-rouge">ObjectSpace.each_object</code> позволяет перебрать все «живые» объекты, при необходимости отобрав их по классу. Поскольку
в Ruby всё — объекты, и при этом класс <code class="language-plaintext highlighter-rouge">Class</code> является наследником <code class="language-plaintext highlighter-rouge">Module</code>, мы можем спокойно использовать отбор
по <code class="language-plaintext highlighter-rouge">Module</code>.</p>

<p>Таким образом мы можем получить общую картину классов и модулей, использовав вышеприведенный метод <code class="language-plaintext highlighter-rouge">header</code> и немного
переделав <code class="language-plaintext highlighter-rouge">print_module</code>:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_module</span> <span class="n">mod</span>
  <span class="n">title</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="n">mod</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">downcase</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">mod</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">if</span> <span class="no">Class</span> <span class="o">===</span> <span class="n">mod</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span><span class="p">.</span><span class="nf">superclass</span> <span class="o">!=</span> <span class="kp">nil</span>
    <span class="n">title</span> <span class="o">+=</span> <span class="s2">" &lt; </span><span class="si">#{</span><span class="n">mod</span><span class="p">.</span><span class="nf">superclass</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="nb">puts</span> <span class="n">title</span>
  <span class="nb">puts</span> <span class="s2">"  ancestors: </span><span class="si">#{</span><span class="n">mod</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">puts</span> <span class="s2">"  constants:"</span>
  <span class="n">mod</span><span class="p">.</span><span class="nf">constants</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"    </span><span class="si">#{</span><span class="n">c</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="nb">puts</span> <span class="s2">"  class methods:"</span>
  <span class="n">mod</span><span class="p">.</span><span class="nf">public_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"    </span><span class="si">#{</span><span class="n">header</span><span class="p">(</span><span class="n">mod</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="nb">puts</span> <span class="s2">"  instance methods:"</span>
  <span class="n">mod</span><span class="p">.</span><span class="nf">public_instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"    </span><span class="si">#{</span><span class="n">header</span><span class="p">(</span><span class="n">mod</span><span class="p">.</span><span class="nf">instance_method</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="nb">puts</span> <span class="s1">''</span>
<span class="k">end</span>

<span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">each_object</span><span class="p">(</span><span class="no">Module</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">mod</span><span class="o">|</span>
  <span class="n">print_module</span> <span class="n">mod</span>
<span class="k">end</span></code></pre>
</figure>

<p>Полный вывод такой программы получится совсем гигантским<sup id="fnref:out"><a href="#fn:out" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>, поэтому приведу лишь малую часть, относящуюся к специально
созданному для примера классу:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="no">ALPHA</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="nb">attr_accessor</span> <span class="ss">:beta</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">alpha</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span>
    <span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre>
</figure>

<p>Вот, что мы для него получим:</p>

<figure class="highlight">
  <pre><code class="language-text" data-lang="text">class Alpha &lt; Object
  ancestors: Alpha, Object, Kernel, BasicObject
  constants:
    ALPHA
  class methods:
    beta() [intro06.rb:40]
    beta=(arg0) [intro06.rb:40]
    allocate() [&lt;binary&gt;]
    new(*arg0) [&lt;binary&gt;]
    superclass() [&lt;binary&gt;]
  instance methods:
    alpha(a, b = &lt;..&gt;, *c) [intro06.rb:43]</code></pre>
</figure>

<h2 id="и-что-это-нам-дает">И что это нам дает?</h2>

<p>Механизм интроспекции достаточно универсальный и «неприкладной», поэтому его, с одной стороны, трудно применить
к чему-нибудь практическому «в лоб», а с другой — есть масса случаев, когда он в той или иной мере полезен. Я, пожалуй,
выделю только некоторые направления:</p>

<ul>
  <li>
    <p>Мы можем создавать прокси-объекты, полностью (снаружи) эквивалентные некоторым заданным, при этом возможные изменения
исходных объектов, которые могут разрабатываться где-то в другом месте другими людьми, нас не волнуют, поскольку все
делается автоматически.</p>
  </li>
  <li>
    <p>В сложных системах с подключением сторонних скриптов в качестве плагинов или компонентов интроспекция дает больший контроль
за совместимостью, проверкой функциональности и так далее. Например, введя изменения в интерфейс плагинов в очередной версии,
мы можем автоматически определять устаревшие плагины (то есть — с устаревшим интерфейсом) и как-то корректно их обрабатывать,
например, создавая прокси-обертку (см. предыдущий пункт).</p>
  </li>
  <li>
    <p>Развитые инструменты интроспекции можно (и нужно) использовать для отладки, логирования, автоматического тестирования
и так далее. То есть в инструментах для создания и обслуживания кода — не нужно отдельно парсить исходные тексты, интерпретатор
уже делает это за нас, причем таким же образом, как и при «боевом» выполнении. Так что, если кто задумывает написать IDE
для Ruby, этими средствами пренебрегать никак нельзя.</p>

    <ul>
      <li>
        <p>Кроме того, не стоит забывать, что в Ruby с его развитыми средствами метапрограммирования, изучая код, относящийся
к какому-нибудь классу, мы никогда не можем быть уверены, что это весь код, относящийся к этому классу. Иными словами,
получить полную информацию о том, как выглядит некий класс в определенный момент исполнения программы, мы можем только
в этот момент исполнения.</p>
      </li>
      <li>
        <p>Соответственно, данные инструменты могут стать очень хорошим подспорьем как при обучении Ruby, так и при изучении чужого кода,
особенно если он плохо документирован, что, к сожалению, в современной программной индустрии скорее норма, чем исключение.</p>
      </li>
    </ul>
  </li>
</ul>

<p>В целом, информация о структуре программы во время выполнения, хоть и не уменьшает сложность, однако дает дополнительные возможности
с ней как-то справляться.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:gist">
      <p>Полные тексты примеров размещены на GitHub — <a href="https://gist.github.com/shikhalev/12090b4e64340d9d8c2e">https://gist.github.com/shikhalev/12090b4e64340d9d8c2e</a>. <a href="#fnref:gist" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:vers">
      <p>На момент написания статьи версия 1.9.3 еще считается актуальной, впрочем, ее официальная поддержка заканчивается в феврале 2015…
     Тем не менее, столкнуться с ее использованием в старом коде вполне вероятно. <a href="#fnref:vers" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:context">
      <p>О контекстах см. статью <a href="/2015/04/ruby-context.html">«Блоки и контекст в Ruby»</a>, Системный администратор, январь-февраль 2014. <a href="#fnref:context" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:out">
      <p>Данный вывод приведен вместе с исходниками на GitHub в файле list.txt. <a href="#fnref:out" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Иван Шихалев</name></author><category term="[&quot;tech&quot;, &quot;programming&quot;, &quot;ruby&quot;, &quot;pub&quot;, &quot;samag&quot;]" /><category term="интроспекция" /><category term="метапрограммирование" /><summary type="html"><![CDATA[Что программа может знать о самой себе?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://shikhalev.github.io/img/2016/03/09/introspection/screen-introspection-640x640-500-261-0-0.webp" /><media:content medium="image" url="https://shikhalev.github.io/img/2016/03/09/introspection/screen-introspection-640x640-500-261-0-0.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Мета­программи­ро­вание в Ruby: разбор примера</title><link href="https://shikhalev.github.io/2016/01/metaprogramming.html" rel="alternate" type="text/html" title="Мета­программи­ро­вание в Ruby: разбор примера" /><published>2016-01-27T00:00:00+00:00</published><updated>2016-01-27T00:00:00+00:00</updated><id>https://shikhalev.github.io/2016/01/metaprogramming</id><content type="html" xml:base="https://shikhalev.github.io/2016/01/metaprogramming.html"><![CDATA[<p><a href="http://samag.ru/archive/article/2842">Оригинал этой статьи опубликован в журнале «Системный администратор» №12 (145) за декабрь 2014</a>.</p>

<hr />

<figure class="__figure __implicit_figure __right" style="max-width:158px;padding: 5px;"><a href="http://samag.ru/archive/article/2842"><img src="/img/2016/01/27/metaprogramming/145-158.webp" class="__image" /></a></figure>

<div class="note">
  <p><strong>Добавление собственных абстракций в объектную модель — это просто. И интересно.</strong></p>

  <p>Авторы книги «Programming Ruby: The Pragmatic Programmers’ Guide» называют метапрограммированием расширение и изменение
абстракций языка (тогда как собственно программирование пользуется теми, что есть). Конечно, можно поспорить о том, что
считать такой абстракцией, а что нет, однако нельзя не заметить, что в современных динамических языках, таких как Ruby или,
например, Python, легко делаются некоторые вещи, которые в классических языках находились именно на языковом уровне и жестко
определялись компилятором. Тут можно вспомнить, для примера, декораторы, о которых я писал в сентябре прошлого года<sup id="fnref:deco"><a href="#fn:deco" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.
И сейчас мы рассмотрим нечто подобное. В процессе я буду делать обобщающие отступления, переходя от частного примера к общим
принципам программирования в Ruby.</p>
</div>

<!--more-->

<h2 id="формулировка-задачи">Формулировка задачи</h2>

<p>В объектно-ориентированных языках, как правило, имеются такие абстракции как методы и свойства. В Ruby свойства называются
атрибутами, что, впрочем, сути не меняет. Однако в Ruby мы можем и сами определить аналогичные конструкции с нужной нам
специфической функциональностью. Так и поступим.</p>

<p>Наши свойства будут поддерживать:</p>

<ul>
  <li>контроль присваиваемых значений;</li>
  <li>значения по умолчанию;</li>
  <li>события, вызываемые при установке значения.</li>
</ul>

<p>Определение свойств будет выглядеть примерно так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">property</span> <span class="ss">:alpha</span><span class="p">,</span> <span class="ss">filter: </span><span class="no">String</span><span class="p">,</span> <span class="ss">default: </span><span class="s1">''</span>
<span class="n">property</span> <span class="ss">:beta</span><span class="p">,</span> <span class="ss">:gamma</span><span class="p">,</span> <span class="ss">filter: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">default: </span><span class="mi">0</span>
<span class="n">property</span> <span class="ss">:delta</span><span class="p">,</span> <span class="ss">filter: </span><span class="no">Float</span><span class="p">,</span>
    <span class="ss">default: </span><span class="mf">1.0</span> <span class="k">do</span> <span class="o">|</span><span class="n">obj</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
  <span class="nb">p</span> <span class="p">[</span><span class="n">obj</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
<span class="k">end</span></code></pre>
</figure>

<p>Последний вариант задает обработчик события. В случае, когда никаких именованных параметров, даже <code class="language-plaintext highlighter-rouge">filter</code>, не задано, <code class="language-plaintext highlighter-rouge">property</code>
будет работать, в сущности, аналогично стандартному <code class="language-plaintext highlighter-rouge">attr_accessor</code>. Заметим, что атрибуты в Ruby определяются не ключевыми словами,
а приватными методами класса <code class="language-plaintext highlighter-rouge">Module</code>. Логично будет пойти тем же путем.</p>

<p class="note"><em>Замечание:</em> ключевые слова <code class="language-plaintext highlighter-rouge">module</code> и <code class="language-plaintext highlighter-rouge">class</code> в Ruby не формируют какое-то сакральное определение, принципиально отличающееся
от остальной части программы, а просто переводят исполнение в контекст модуля (или класса, соответственно), по необходимости
создавая его. Это значит, что внутри определений мы можем писать, в общем-то, произвольный код, учитывая контекст, конечно<sup id="fnref:context"><a href="#fn:context" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.
При этом благодаря необязательности скобок при вызове, такие методы, как <code class="language-plaintext highlighter-rouge">attr</code>, <code class="language-plaintext highlighter-rouge">include</code>, <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">module_function</code>, выглядят
структурными элементами языка.</p>

<h2 id="минимальный-вариант">Минимальный вариант</h2>

<p>Начнем с самого простого — реализуем аналог <code class="language-plaintext highlighter-rouge">attr_accessor</code>. Заявленный выше функционал добавим после. Определение выглядит так<sup id="fnref:gist"><a href="#fn:gist" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Module</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">prop</span> <span class="nb">name</span>
    <span class="n">varnm</span> <span class="o">=</span> <span class="s2">"@</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
    <span class="n">getnm</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="n">setnm</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">="</span>
    <span class="n">define_method</span> <span class="n">getnm</span> <span class="k">do</span>
      <span class="nb">instance_variable_get</span> <span class="n">varnm</span>
    <span class="k">end</span>
    <span class="n">define_method</span> <span class="n">setnm</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
      <span class="nb">instance_variable_set</span> <span class="n">varnm</span><span class="p">,</span> <span class="n">value</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">property</span> <span class="o">*</span><span class="n">names</span>
    <span class="n">names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">nm</span><span class="o">|</span>
      <span class="n">prop</span> <span class="n">nm</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre>
</figure>

<p>Собственно определение (единственного) свойства выделено в отдельный метод prop для ясности. А для проверки напишем следующее:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>
  <span class="n">property</span> <span class="ss">:alpha</span><span class="p">,</span> <span class="ss">:beta</span>
  <span class="nb">attr_accessor</span> <span class="ss">:gamma</span>
<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>

<span class="n">a</span><span class="p">.</span><span class="nf">alpha</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a</span><span class="p">.</span><span class="nf">beta</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">a</span><span class="p">.</span><span class="nf">gamma</span> <span class="o">=</span> <span class="mi">3</span>

<span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="nf">alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="nf">beta</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="nf">gamma</span><span class="p">]</span>
<span class="nb">p</span> <span class="n">a</span></code></pre>
</figure>

<p>И выполним:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo00.rb
<span class="go">[1, 2, 3]
♯‹Alpha:0x0000000260bbc8 @alpha=1, @beta=2, @gamma=3›</span></code></pre>
</figure>

<p>Нетрудно видеть, что нет разницы между работой нашего метода и стандартного. Теперь можно двигаться дальше, но сначала некоторые пояснения.</p>

<p>Свойство в Ruby — это пара методов: один возвращает значение одноименной переменной экземпляра объекта, а второй — устанавливает.
Имя метода-сеттера заканчивается символом <code class="language-plaintext highlighter-rouge">=</code>, это необходимо и достаточно, чтобы в дальнейшем можно было использовать такой метод
в левой части оператора присваивания. В принципе, привязка именно к переменной объекта необязательна, методы могут использовать
любые данные.</p>

<p>Из приведенного кода можно видеть, что <code class="language-plaintext highlighter-rouge">define_method</code> (в отличие от <code class="language-plaintext highlighter-rouge">def</code>) работает с замыканием, таким образом мы можем использовать
в нем внешние переменные. Другим вариантом могло бы быть формирование строки кода и выполнение ее через <code class="language-plaintext highlighter-rouge">module_eval</code>, но такой способ
даст замедление за счет того, что эта строка будет разбираться и компилироваться при каждом вызове, тогда как в нашем случае разбор
производится однократно, при первом проходе.</p>

<h2 id="значения-по-умолчанию">Значения по умолчанию</h2>

<p>Если мы сейчас обратимся к определенному нами свойству, значение которого не установлено, то получим <code class="language-plaintext highlighter-rouge">nil</code>, так же как для стандартного
атрибута. Это поведение можно переопределить. Введем два именованных параметра: <code class="language-plaintext highlighter-rouge">default</code> — значение по умолчанию; и <code class="language-plaintext highlighter-rouge">default_proc</code> — объект,
приводимый к классу <code class="language-plaintext highlighter-rouge">Proc</code>, который будет вызываться для инициализации внутренней переменной, если она не установлена при первом вызове
свойства. Если заданы оба, преимущество имеет <code class="language-plaintext highlighter-rouge">default_proc</code>.</p>

<p>Метод <code class="language-plaintext highlighter-rouge">prop</code> теперь будет выглядеть так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">prop</span> <span class="nb">name</span><span class="p">,</span> <span class="ss">default: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">default_proc: </span><span class="kp">nil</span>
  <span class="n">varnm</span> <span class="o">=</span> <span class="s2">"@</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">getnm</span> <span class="o">=</span> <span class="nb">name</span>
  <span class="n">setnm</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">="</span>
  <span class="n">define_method</span> <span class="n">getnm</span> <span class="k">do</span>
    <span class="k">if</span> <span class="o">!</span> <span class="n">instance_variable_defined?</span><span class="p">(</span><span class="n">varnm</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">default_proc</span>
        <span class="nb">instance_variable_set</span> <span class="n">varnm</span><span class="p">,</span>
              <span class="n">default_proc</span><span class="p">.</span><span class="nf">to_proc</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
      <span class="k">else</span>
        <span class="nb">instance_variable_set</span> <span class="n">varnm</span><span class="p">,</span> <span class="n">default</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="nb">instance_variable_get</span> <span class="n">varnm</span>
  <span class="k">end</span>
  <span class="n">define_method</span> <span class="n">setnm</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="nb">instance_variable_set</span> <span class="n">varnm</span><span class="p">,</span> <span class="n">value</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>К методу <code class="language-plaintext highlighter-rouge">property</code> тоже добавятся соответствующие именованные параметры, которые он просто передаст в prop для каждого имени свойства.
Проверим, что у нас получилось, следующим кодом:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>
  <span class="n">property</span> <span class="ss">:alpha</span><span class="p">,</span> <span class="ss">default: </span><span class="mi">100</span>
  <span class="n">property</span> <span class="ss">:beta</span><span class="p">,</span>
    <span class="ss">default_proc: </span><span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">o</span><span class="o">|</span> <span class="n">o</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span> <span class="p">}</span>
  <span class="n">property</span> <span class="ss">:gamma</span><span class="p">,</span> <span class="ss">default_proc: :class</span>
<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>

<span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="nf">alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="nf">beta</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="nf">gamma</span><span class="p">]</span>
<span class="nb">p</span> <span class="n">a</span></code></pre>
</figure>

<p>Вывод должен быть примерно следующий:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo01.rb
<span class="go">[100, "Alpha", Alpha]
♯‹Alpha:0x00000002252a90 @alpha=100, @beta="Alpha", @gamma=Alpha›</span></code></pre>
</figure>

<p>Стоит заметить, что для последнего свойства мы применили немного необычный фокус: оказывается, значения класса <code class="language-plaintext highlighter-rouge">Symbol</code> имеют метод
<code class="language-plaintext highlighter-rouge">to_proc</code>, который формально можно записать как:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">to_proc</span>
  <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="o">|</span> <span class="n">obj</span><span class="p">.</span><span class="nf">send</span> <span class="nb">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="p">}</span>
<span class="k">end</span></code></pre>
</figure>

<p>То есть, получается вызов метода с соответствующим именем для объекта, переданного первым параметром, и с аргументами из остальных
параметров, если таковые присутствуют. При этом собственного метода <code class="language-plaintext highlighter-rouge">call</code> объекты класса <code class="language-plaintext highlighter-rouge">Symbol</code> не имеют — преобразование <code class="language-plaintext highlighter-rouge">to_proc</code>
здесь обязательно.</p>

<h2 id="вызов-события">Вызов события</h2>

<p>Добавим к параметрам <code class="language-plaintext highlighter-rouge">prop</code> (и <code class="language-plaintext highlighter-rouge">property</code> соответственно) <code class="language-plaintext highlighter-rouge">&amp;block</code> — собственно обработчик, и преобразуем слегка определение сеттера
из предыдущих примеров.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">define_method</span> <span class="n">setnm</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
  <span class="nb">instance_variable_set</span> <span class="n">varnm</span><span class="p">,</span> <span class="n">value</span>
  <span class="k">if</span> <span class="n">block</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">call</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">value</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>Тестируем:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>
  <span class="n">property</span> <span class="ss">:alpha</span>
  <span class="n">property</span> <span class="ss">:beta</span> <span class="k">do</span> <span class="o">|</span><span class="n">obj</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
    <span class="nb">p</span> <span class="p">[</span><span class="n">obj</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>

<span class="n">a</span><span class="p">.</span><span class="nf">alpha</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">a</span><span class="p">.</span><span class="nf">beta</span> <span class="o">=</span> <span class="mi">200</span></code></pre>
</figure>

<p>Получаем:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo02.rb
<span class="go">[♯‹Alpha:0x000000025d2e18 @alpha=100, @beta=200›, :beta, 200]</span></code></pre>
</figure>

<h2 id="проверка-значений">Проверка значений</h2>

<p>Добавим к <code class="language-plaintext highlighter-rouge">prop</code> следующие именованные аргументы: <code class="language-plaintext highlighter-rouge">filter</code> — собственно фильтр, и <code class="language-plaintext highlighter-rouge">on_invalid</code> — параметр, определяющий,
как будет обрабатываться попытка присвоить неподходящее значение. Вообще говоря, тут может быть множество вариантов поведения,
но два основных — это проигнорировать и сгенерировать исключение, поэтому мы сделаем так: если в параметре <code class="language-plaintext highlighter-rouge">on_invalid</code>
передан класс исключения, вызываем <code class="language-plaintext highlighter-rouge">raise</code>, если <code class="language-plaintext highlighter-rouge">nil</code> — игнорируем. А чтобы дать возможность определить какое-то произвольное
поведение, будем принимать также объекты класса <code class="language-plaintext highlighter-rouge">Proc</code>.</p>

<p>Изменим определение сеттера следующим образом:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">define_method</span> <span class="n">setnm</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
  <span class="k">if</span> <span class="n">filter</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">filter</span> <span class="o">===</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="no">Class</span> <span class="o">===</span> <span class="n">on_invalid</span> <span class="o">&amp;&amp;</span> <span class="n">on_invalid</span> <span class="o">&lt;=</span> <span class="no">Exception</span>
      <span class="k">raise</span> <span class="n">on_invalid</span><span class="p">,</span> <span class="s2">"Invalid property (</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">)"</span> <span class="o">+</span>
          <span class="s2">" value: </span><span class="si">#{</span><span class="n">value</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">!"</span><span class="p">,</span> <span class="nb">caller</span>
    <span class="k">elsif</span> <span class="no">Proc</span> <span class="o">===</span> <span class="n">on_invalid</span>
      <span class="n">on_invalid</span><span class="p">.</span><span class="nf">call</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">value</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="nb">instance_variable_set</span> <span class="n">varnm</span><span class="p">,</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">block</span>
      <span class="n">block</span><span class="p">.</span><span class="nf">call</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">value</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>И проверим при помощи следующего кода:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="n">property</span> <span class="ss">:alpha</span><span class="p">,</span> <span class="ss">filter: </span><span class="no">Integer</span>
  <span class="n">property</span> <span class="ss">:beta</span><span class="p">,</span>
      <span class="ss">filter: </span><span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="no">Integer</span> <span class="o">===</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">},</span>
      <span class="ss">on_invalid: </span><span class="no">StandardError</span>

<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>

<span class="n">a</span><span class="p">.</span><span class="nf">alpha</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">a</span><span class="p">.</span><span class="nf">beta</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nb">p</span> <span class="n">a</span>

<span class="n">a</span><span class="p">.</span><span class="nf">alpha</span> <span class="o">=</span> <span class="s2">"String"</span>
<span class="nb">p</span> <span class="n">a</span>

<span class="n">a</span><span class="p">.</span><span class="nf">beta</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="nb">p</span> <span class="n">a</span></code></pre>
</figure>

<p>Результат должен получиться примерно такой:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo03.rb
<span class="go">♯‹Alpha:0x00000001b193c8 @alpha=11, @beta=2›
♯‹Alpha:0x00000001b193c8 @alpha=11, @beta=2›
demo03.rb:24:in `‹main›': Invalid property (beta) value: -1! (StandardError)</span></code></pre>
</figure>

<p>Здесь хотелось бы отметить оператор соответствия — <code class="language-plaintext highlighter-rouge">===</code>, который мы использовали для проверки условия. В отличие от, например, JavaScript,
где три знака «равно» означают точное равенство, в Ruby этот оператор принято трактовать как «правая часть соответствует левой» — обычно это
означает равенство, но не всегда: если в левой части класс, то выполняется проверка принадлежности классу (с учетом наследования), если диапазон —
вхождения в диапазон… Так же можно проверять соответствие регулярному выражению, а значения класса <code class="language-plaintext highlighter-rouge">Proc</code> будут выполнены с правой частью
в качестве аргумента, что и позволило нам записать условие для свойства <code class="language-plaintext highlighter-rouge">beta</code> в коротком и удобочитаемом виде.</p>

<p>Кроме того, мы можем определить этот оператор для каких-то своих классов условий, задав ему произвольное поведение. Или переопределить его
для каких-либо стандартных классов, что, впрочем, может иметь непредсказуемые последствия.</p>

<h2 id="что-дальше">Что дальше?</h2>

<p>В общем-то, задача, поставленная в начале статьи, решена. Замечу только, что совершенно необязательно формировать один большой
метод с несколькими условными ветвлениями — можно, и даже нужно с точки зрения оптимизации, проверять <code class="language-plaintext highlighter-rouge">filter</code> снаружи, и уже
в зависимости от его значения определять метод-сеттер: простой без проверок, игнорирующий, с исключением, или же с обработкой.</p>

<p>Вынесение всего, что возможно — в данном случае это проверки условий — из повторяющейся части (метода) в выполняемую однократно
при его определении — азы оптимизации, и тут возможность задавать определения на ходу, доступная в динамических языках, очень
нам на руку.</p>

<h2 id="практический-смысл">Практический смысл</h2>

<p>Собственно, даже такая простая, взятая для примера, функциональность не бесполезна. А еще можно создавать свойства (поля)
с внешним хранением данных, с дополнительными параметрами отображения и так далее и тому подобное. Можно привязать класс Ruby
к таблице базы данных, определить поля, ключи, связи между таблицами… В общем, легко создать удобный и прозрачный ORM<sup id="fnref:orm"><a href="#fn:orm" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.
Что, кстати, и сделано в фреймворке Ruby on Rails (см. <code class="language-plaintext highlighter-rouge">ActiveRecord</code> и <code class="language-plaintext highlighter-rouge">ActiveModel</code>).</p>

<p>Естественно, базами данных область применения не ограничивается. Важно помнить, что внутри определений классов и модулей
мы можем использовать все средства языка и, соответственно, запрограммировать какие-то сложные вещи в короткие «однострочные»
конструкции. Это напоминает макросы в некоторых компилируемых языках, но, поскольку определения доступны во время выполнения,
дает гораздо более широкие возможности.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:deco">
      <p>Статья <a href="/2015/03/decorator.html">«Декораторы в Ruby»</a>. «Системный администратор» № 9 (130), сентябрь 2013. Стр. 68–71. <a href="#fnref:deco" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:context">
      <p>Подробнее о контекстах см. мою статью <a href="/2015/04/ruby-context.html">«Блоки и контекст в Ruby»</a>. «Системный администратор» № 1–2 (134–135), январь-февраль 2014. Стр. 111–115. <a href="#fnref:context" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:gist">
      <p>Полные тексты примеров размещены на GitHub — <a href="https://gist.github.com/shikhalev/5f19659a7ed82ce83c58">https://gist.github.com/shikhalev/5f19659a7ed82ce83c58</a>. <a href="#fnref:gist" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:orm">
      <p>Object-Relational Mapping — отображение реляционных баз данных в объектную модель. <a href="#fnref:orm" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Иван Шихалев</name></author><category term="[&quot;tech&quot;, &quot;programming&quot;, &quot;ruby&quot;, &quot;pub&quot;, &quot;samag&quot;]" /><category term="метапрограммирование" /><summary type="html"><![CDATA[Добавление собственных абстракций в объектную модель — это просто. И интересно.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://shikhalev.github.io/img/2016/01/27/metaprogramming/screen-meta-640x640-500-261-0-0.webp" /><media:content medium="image" url="https://shikhalev.github.io/img/2016/01/27/metaprogramming/screen-meta-640x640-500-261-0-0.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Ruby и многозадачность</title><link href="https://shikhalev.github.io/2015/04/ruby-multitasking.html" rel="alternate" type="text/html" title="Ruby и многозадачность" /><published>2015-04-04T00:00:00+00:00</published><updated>2015-04-04T00:00:00+00:00</updated><id>https://shikhalev.github.io/2015/04/ruby-multitasking</id><content type="html" xml:base="https://shikhalev.github.io/2015/04/ruby-multitasking.html"><![CDATA[<p><a href="http://samag.ru/archive/article/2645">Оригинал этой статьи опубликован в журнале «Системный администратор» №3 (136) за март 2014</a>.</p>

<hr />

<figure class="__figure __implicit_figure __right" style="max-width:158px;padding: 5px;"><a href="http://samag.ru/archive/article/2645"><img src="/img/2015/04/04/ruby-multitasking/136-158.webp" class="__image" /></a></figure>

<div class="note">
  <p><strong>В статье рассматриваются основные средства работы с потоками (threads) и процессами в языке и стандартной библиотеке Ruby</strong></p>

  <p>Немного о терминологии: англоязычный термин «thread» на русский переводится в двух вариантах — как «поток» и как «нить».
Второй вариант точнее и не вызывает неоднозначности с потоками данных (streams), однако первый уже прижился в качестве основного.
Кроме того, есть еще производные термины и варианты вроде «многонитевость» (или «многонитность»), но они мне не встречались и,
честно говоря, режут глаз. Поэтому я буду использовать «поток».</p>
</div>

<p>Прежде, чем перейти к описаниям имеющегося инструментария, хотелось бы заметить, что Ruby создавался не как специальный язык
параллельного программирования, при этом во время его создания и становления многозадачность уже стала привычной и необходимой.
Из этих двух посылок, в об­щем-то, можно вывести текущую картину: никаких специфических концепций мы в нем не увидим, только
поддержку привычной для всех языков общего назначения модели с некоторыми нюансами реализации.</p>

<!--more-->

<h2 id="многопоточность">Многопоточность</h2>

<p>Потоки позволяют программисту распараллелить выполнение задачи в рамках одного процесса. Это дает заметный выигрыш в двух основных
случаях: во-первых, когда есть аппаратные ресурсы для параллельных вычислений, т.е. многоядерная или многопроцессорная архитектура
(что для современных компьютеров норма), и во-вторых, когда какие-то подзадачи вынуждены тратить время на ожидание внешних ресурсов,
будь то дисковая подсистема, сеть, или действия пользователя.</p>

<p>Плохая новость в том, что в действительности потоки Ruby не параллельны, и выигрыша от многоядерности нам получить не удастся.
Несмотря на то, что актуальные версии интерпретатора используют потоки операционной системы, управление ими построено так, что
в определенный момент времени выполняется только один поток. В старых версиях (по 1.8.7 включительно) использовались так называемые
«зеленые» потоки, исполняющиеся в рамках одного системного, в новых — действует механизм GIL (global interpreter lock). Хорошей же
новостью можно считать то, что этот механизм защищает от некоторых (но не всех) потенциальных конфликтов между потоками.
Ниже о синхронизации еще поговорим, а пока отметим, что второй выигрыш — в случае ожидания внешних ресурсов — нам остается вполне
доступен, таким образом, польза от использования потоков в Ruby безусловно есть.</p>

<p>Работа с потоками в Ruby в основном сосредоточена в классе <code class="language-plaintext highlighter-rouge">Thread</code> — в самом простом случае мы создаем объект этого класса из блока
(или множество объектов) и ждем завершения<sup id="fnref:gist"><a href="#fn:gist" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="nb">puts</span> <span class="s1">'begin'</span>

<span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">i</span> <span class="p">}</span>
<span class="k">end</span>

<span class="c1"># sleep 0</span>
<span class="nb">puts</span> <span class="s1">'---'</span>

<span class="n">th</span><span class="p">.</span><span class="nf">join</span>

<span class="nb">puts</span> <span class="s1">'end'</span></code></pre>
</figure>

<p>Результат будет такой:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo01.rb
<span class="go">begin
---
1
2
3
end</span></code></pre>
</figure>

<p>Если же мы раскомментируем строчку «<code class="language-plaintext highlighter-rouge">sleep 0</code>», положение строки с дефисами относительно цифр станет непредсказуемым,
а если вместо ноля напишем «<code class="language-plaintext highlighter-rouge">1</code>», или даже «<code class="language-plaintext highlighter-rouge">0.1</code>», дефисы будут стабильно выводиться после тройки, поскольку поток
полностью отработает раньше.</p>

<p>Что еще можно сделать с потоком, кроме как запустить его, и смиренно дождаться завершения (именно это делает метод <code class="language-plaintext highlighter-rouge">join</code>)?
Можно его приостановить (метод класса <code class="language-plaintext highlighter-rouge">Thread.stop</code>, вызываемый внутри потока), «разбудить», т.е. продолжить выполнение
с момента остановки (<code class="language-plaintext highlighter-rouge">wakeup</code>), прекратить, не дожидаясь окончания работы (<code class="language-plaintext highlighter-rouge">terminate</code>)… Такой пример:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s1">'started'</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">stop</span>
  <span class="nb">puts</span> <span class="s1">'continued'</span>
  <span class="nb">sleep</span> <span class="mi">100</span>
  <span class="nb">puts</span> <span class="s1">'finished'</span>
<span class="k">end</span>

<span class="nb">sleep</span> <span class="mf">0.1</span>
<span class="nb">puts</span> <span class="s1">'wakeup'</span>
<span class="n">th</span><span class="p">.</span><span class="nf">wakeup</span>
<span class="nb">sleep</span> <span class="mi">0</span>
<span class="nb">puts</span> <span class="s1">'terminate'</span>
<span class="n">th</span><span class="p">.</span><span class="nf">terminate</span>
<span class="n">th</span><span class="p">.</span><span class="nf">join</span></code></pre>
</figure>

<p>Даст следующий вывод:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo02.rb
<span class="go">started
wakeup
continued
terminate</span></code></pre>
</figure>

<p>Причем, если мы закомментируем строку «<code class="language-plaintext highlighter-rouge">sleep 0</code>», то до «<code class="language-plaintext highlighter-rouge">continued</code>» дело может и не дойти.</p>

<h3 id="обмен-данными-между-потоками">Обмен данными между потоками</h3>

<p><em>Во-первых,</em> мы можем передавать блоку аргументы при создании потока:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">|</span> <span class="o">...</span> <span class="p">}</span></code></pre>
</figure>

<p><em>Во-вторых,</em> в Ruby любой код возвращает какое-то значение, и результат выполнения блока мы вполне можем получить —
для этого нужно использовать метод <code class="language-plaintext highlighter-rouge">value</code> вместо <code class="language-plaintext highlighter-rouge">join</code>.</p>

<p><em>В-третьих,</em> блок, из которого создается поток, как и любой другой, образует замыкание, т.е. в нем можно обращаться
к любым данным, доступным в месте его объявления<sup id="fnref:context"><a href="#fn:context" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>. Однако здесь нужно помнить о том, что разные потоки могут
обращаться к одним и тем же данным в произвольном порядке.</p>

<p>От одновременного обращения двух потоков к одной переменной нас защищает GIL, о котором было сказано выше,
он же делает многие (но не все) стандартные методы стандартных классов атомарными, но этого недостаточно.
Сколько раз выведет «<code class="language-plaintext highlighter-rouge">true</code>» следующий код?</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">flag</span> <span class="o">=</span> <span class="kp">true</span>

<span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s1">'true'</span> <span class="k">if</span> <span class="n">flag</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Thread</span><span class="p">.</span><span class="nf">list</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">th</span><span class="o">|</span>
  <span class="k">if</span> <span class="n">th</span> <span class="o">!=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span>
    <span class="n">th</span><span class="p">.</span><span class="nf">join</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>Правильный ответ: непредсказуемо, если запустить скрипт достаточно много раз, можно увидеть все варианты от одного до пяти.
Хотя проверка флага и присвоение ему значения сами по себе атомарны и не вызывают конфликтов, <em>между ними</em> легко может произойти
переключение между потоками.</p>

<p>Самый простой способ обеспечить синхронизацию — использовать метод <code class="language-plaintext highlighter-rouge">Thread.exclusive</code>, в предыдущем примере это бы выглядело так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="no">Thread</span><span class="p">.</span><span class="nf">exclusive</span> <span class="k">do</span>
      <span class="nb">puts</span> <span class="s1">'true'</span> <span class="k">if</span> <span class="n">flag</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>В более сложных случаях, когда у нас, например, две переменные, обращение к каждой из которых нужно синхронизировать
независимо друг от друга, следует использовать объекты класса <code class="language-plaintext highlighter-rouge">Mutex</code> и их метод <code class="language-plaintext highlighter-rouge">synchronize</code>.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">alpha</span> <span class="o">=</span> <span class="kp">true</span>
<span class="n">alpha_m</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
<span class="n">beta</span> <span class="o">=</span> <span class="kp">true</span>
<span class="n">beta_m</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>

<span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">alpha_m</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="nb">puts</span> <span class="s1">'alpha'</span> <span class="k">if</span> <span class="n">alpha</span>
      <span class="n">alpha</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>
    <span class="n">beta_m</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="nb">puts</span> <span class="s1">'beta'</span> <span class="k">if</span> <span class="n">beta</span>
      <span class="n">beta</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>Собственно, <code class="language-plaintext highlighter-rouge">Thread.exclusive</code> делает то же самое, но при этом использует один и тот же объект класса <code class="language-plaintext highlighter-rouge">Mutex</code> на все случаи.</p>

<p>Кроме такой безусловной синхронизации объекты <code class="language-plaintext highlighter-rouge">Mutex</code> позволяют и более гибко работать с блокировками — в каких-то случаях
не дожидаться освобождения заблокированного объекта, а выполнить другие действия (например, вывести сообщение об ошибке).
А еще ручное блокирование/разблокирование дает простор для глупых ошибок по невнимательности, поэтому я бы не рекомендовал
им пользоваться без особой на то необходимости.</p>

<p><em>В-четвертых,</em> мы можем получать и устанавливать так называемые переменные потока посредством методов <code class="language-plaintext highlighter-rouge">thread_variable_get</code>/<code class="language-plaintext highlighter-rouge">set</code>.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">sleep</span> <span class="mf">0.1</span>
  <span class="nb">p</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">thread_variable_get</span> <span class="s1">'alpha'</span>
<span class="k">end</span>

<span class="n">th</span><span class="p">.</span><span class="nf">thread_variable_set</span> <span class="s1">'alpha'</span><span class="p">,</span> <span class="ss">:alpha</span>

<span class="n">th</span><span class="p">.</span><span class="nf">join</span></code></pre>
</figure>

<p>Сюда же отнесем обращение к переменным, принадлежащим текущему «волокну» (fiber) потока — пример выше можно переписать так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">sleep</span> <span class="mf">0.1</span>
  <span class="nb">p</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="s1">'alpha'</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">th</span><span class="p">[</span><span class="s1">'alpha'</span><span class="p">]</span> <span class="o">=</span> <span class="ss">:alpha</span>

<span class="n">th</span><span class="p">.</span><span class="nf">join</span></code></pre>
</figure>

<p>Это короче и наглядней, но надо помнить, что в общем случае «волокна» могут меняться.</p>

<p>И, <em>в-пятых,</em> для потоков применимы описываемые ниже способы взаимодействия между процессами.</p>

<h3 id="отступление-о-волокнах">Отступление о «волокнах»</h3>

<p>«Волокна» (fibers) имеют косвенное отношение к теме статьи, но не упомянуть их нельзя, хотя бы
из-за вышеописанного обращения к fiber-local переменным. По сути это сопрограммы, переключение
между которыми происходит не средствами системы (или виртуальной машины), а вручную. Еще их можно
охарактеризовать как подпрограммы, выполнение которых при каждом вызове начинается с того момента,
на котором было остановлено в прошлый раз. Поясню примером:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">f</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">current</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">new</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">current</span>
    <span class="n">current</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">new</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span> <span class="p">[</span><span class="n">last</span><span class="p">,</span> <span class="n">current</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="nb">p</span> <span class="n">f</span><span class="p">.</span><span class="nf">resume</span>
  <span class="nb">sleep</span> <span class="mi">1</span>
<span class="k">end</span></code></pre>
</figure>

<p>В результате получим последовательность пар значений времени предыдущего вызова и текущего.</p>

<p>В целом, это довольно экзотический инструмент, которому в явном виде не так-то просто найти
практическое применение.</p>

<h3 id="дополнительно-о-потоках">Дополнительно о потоках</h3>

<p>Для группировки потоков существует класс <code class="language-plaintext highlighter-rouge">ThreadGroup</code>, который не предоставляет никакой особой функциональности,
кроме контроля за тем, что каждый поток принадлежит одной и только одной группе. Не добавленный ни в какую группу
явно, поток принадлежит <code class="language-plaintext highlighter-rouge">ThreadGroup::Default</code>.</p>

<p>Все классы, упомянутые выше, принадлежат ядру языка и загружаются автоматически, однако есть еще кое-какие возможности,
предоставляемые уже модулями стандартной библиотеки<sup id="fnref:stdlib"><a href="#fn:stdlib" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>. Так, «<code class="language-plaintext highlighter-rouge">require 'thread'</code>» предоставит нам классы <code class="language-plaintext highlighter-rouge">Queue</code>
и <code class="language-plaintext highlighter-rouge">SizedQueue</code>, с функциональностью очереди, как ясно из названия. Во втором случае объем очереди ограничен,
и при достижении ограничения помещение нового элемента будет дожидаться, пока другой поток освободит место.</p>

<p>Еще одна полезная библиотека («<code class="language-plaintext highlighter-rouge">require 'thwait'</code>» и класс <code class="language-plaintext highlighter-rouge">ThreadsWait</code>) позволяет ожидать завершения некоего набора
потоков, как всех вместе, так и по очереди.</p>

<h2 id="процессы-в-ruby">Процессы в Ruby</h2>

<p>Собственно запуск программы на Ruby, как и на любом другом языке — есть запуск процесса. Который, в свою очередь,
может порождать дочерние и общаться как с ними, так и с совершенно независимыми от него. Ключевое отличие дочернего
процесса от потока — независимое адресное пространство — разные процессы не могут никаким образом обращаться к переменным
друг друга.</p>

<p>С точки зрения программиста дочерние процессы делятся на два принципиально разных вида: подпроцессы, порождаемые
из того же кода посредством <code class="language-plaintext highlighter-rouge">fork</code>, и внешние программы.</p>

<p>Как работает <code class="language-plaintext highlighter-rouge">fork</code>? В привычных языках, типа C — это функция, в родительском процессе возвращающая идентификатор дочернего,
а в дочернем — ноль. В Ruby можно ее использовать точно так же, однако более элегантно воспользоваться вариантом с блоком,
который и станет выполняться в дочернем процессе.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span> <span class="k">do</span>
  <span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="nb">sleep</span> <span class="mf">0.01</span>
    <span class="nb">puts</span> <span class="s2">"Child [</span><span class="si">#{</span><span class="no">Process</span><span class="p">.</span><span class="nf">pid</span><span class="si">}</span><span class="s2">]: </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="nb">sleep</span> <span class="mf">0.01</span>
  <span class="nb">puts</span> <span class="s2">"Parent [</span><span class="si">#{</span><span class="no">Process</span><span class="p">.</span><span class="nf">pid</span><span class="si">}</span><span class="s2">]: </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">waitpid</span> <span class="n">pid</span></code></pre>
</figure>

<p>Должен получиться примерно такой вывод:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo09.rb
<span class="go">Parent [9032]: 0
Child [9034]: 0
Parent [9032]: 1
Child [9034]: 1
Parent [9032]: 2
Child [9034]: 2</span></code></pre>
</figure>

<p>Что здесь важно помнить, так это то, что хотя блок при <code class="language-plaintext highlighter-rouge">fork</code> и является замыканием, он получает доступ не к тому же окружению,
в котором определен, а <em>к его копии</em> на момент запуска. Таким образом обмен данными посредством внешних переменных невозможен,
а вопрос о синхронизации не имеет смысла.</p>

<p>Что касается внешних программ, то для их вызова служит несколько методов:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">spawn</code> — асинхронный вызов, который нас и будет интересовать, возвращает идентификатор процесса;</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">system</code> — синхронный вызов (т.е. метод дожидается завершения), возвращает индикатор успешности вызова;</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">exec</code> — синхронный вызов, в случае неудачи вызывает исключение;</p>
  </li>
  <li>
    <p><code>`command`</code> или <code class="language-plaintext highlighter-rouge">%x{command}</code> — самая простая форма — синхронный вызов, возвращает строку, соответствующую выводу программы.</p>
  </li>
</ul>

<p>Собственно, теме данной статьи соответствует только <code class="language-plaintext highlighter-rouge">spawn</code> как асинхронный. Замечу лишь, что <code class="language-plaintext highlighter-rouge">system</code> и <code class="language-plaintext highlighter-rouge">exec</code> используют те же
аргументы. Аргументы описываются следующим образом:</p>

<figure class="highlight">
  <pre><code class="language-text" data-lang="text">spawn(‹env,› command ‹, args›*, ‹options›) → pid</code></pre>
</figure>

<p>Т.е. в начале идет необязательный параметр, устанавливающий дополнительные переменные окружения, затем команда, затем произвольное
количество необязательных же аргументов, и наконец, если последний параметр — хэш, из него берутся опции, позволяющие управлять
правами доступа, текущим каталогом и, самое главное, перенаправлениями ввода-вывода. В самом же простом случае достаточно указать
только команду.</p>

<h3 id="сигналы">Сигналы</h3>

<p>Процессы могут посылать друг другу сигналы и как-то на них реагировать. Вообще говоря, сигналы — это скорее механизм
для общения операционной системы с процессами, и большинство из них зарезервировано под специальные нужды, однако
кое-что можно задействовать и в прикладных целях. Выглядит это, например, так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">child</span> <span class="o">=</span> <span class="nb">fork</span> <span class="k">do</span>
  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="no">Signal</span><span class="p">.</span><span class="nf">trap</span> <span class="ss">:USR1</span> <span class="k">do</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">puts</span> <span class="s2">"Signal USR1: </span><span class="si">#{</span><span class="n">count</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="no">Signal</span><span class="p">.</span><span class="nf">trap</span> <span class="ss">:TERM</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s1">'Signal TERM'</span>
    <span class="nb">exit</span>
  <span class="k">end</span>
  <span class="nb">sleep</span> <span class="mi">1000</span>
  <span class="nb">puts</span> <span class="s1">'Ooops!'</span>
<span class="k">end</span>

<span class="no">Signal</span><span class="p">.</span><span class="nf">trap</span> <span class="ss">:CHLD</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s1">'Child died.'</span>
<span class="k">end</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">kill</span> <span class="ss">:USR1</span><span class="p">,</span> <span class="n">child</span>
<span class="nb">sleep</span> <span class="mf">0.01</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">kill</span> <span class="ss">:USR1</span><span class="p">,</span> <span class="n">child</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">kill</span> <span class="ss">:TERM</span><span class="p">,</span> <span class="n">child</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">wait</span></code></pre>
</figure>

<p>В результате должно получиться:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo10.rb
<span class="go">Signal USR1: 1
Signal USR1: 2
Signal TERM
Child died.</span></code></pre>
</figure>

<p>Метод <code class="language-plaintext highlighter-rouge">Process.kill</code> посылает сигнал, а <code class="language-plaintext highlighter-rouge">Signal.trap</code> устанавливает обработчик сигнала. При этом нетрудно видеть,
что сигнал <code class="language-plaintext highlighter-rouge">CHLD</code> мы не посылали — его отправила система, уведомляя родительский процесс о завершении дочернего.
Отдельно стоит обратить внимание на строку «<code class="language-plaintext highlighter-rouge">sleep 0.01</code>» между двумя отправками. Если ее закомментировать,
то сигнал <code class="language-plaintext highlighter-rouge">USR1</code> будет получен дочерним процессом только один раз, поскольку на момент второй отправки первый
еще не будет обработан — сигналы поступают в очередь и уже имеющиеся там не добавляются.</p>

<p>К сожалению, посредством сигналов мы можем сообщить процессу только о наступлении некоторого события, без подробной
информации. А всю информацию между процессами нужно передавать средствами ввода-вывода.</p>

<h3 id="каналы-ввода-вывода">Каналы ввода-вывода</h3>

<p>Общим способом для любых дочерних процессов будет перенаправление ввода-вывода посредством каналов (pipes).
Для внутренних подпроцессов это выглядит так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">child</span> <span class="o">=</span> <span class="nb">fork</span> <span class="k">do</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span> <span class="s1">'From Child'</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="n">msg</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span>
<span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="nb">p</span> <span class="n">msg</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">wait</span></code></pre>
</figure>

<p>Здесь существенно, что оба процесса первым делом закрывают ненужные «концы» канала. Если этого не сделать, то возможны
проблемы с некорректным определением конца файла.</p>

<p>В случае внешних команд все похоже, а «пишущий конец» канала передаем в специальном хэш-значении в последнем параметре spawn:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">child</span> <span class="o">=</span> <span class="n">spawn</span> <span class="s2">"echo 'External Child'"</span><span class="p">,</span>
    <span class="p">[</span> <span class="no">STDERR</span><span class="p">,</span> <span class="no">STDOUT</span> <span class="p">]</span> <span class="o">=&gt;</span> <span class="n">wr</span>

<span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="n">msg</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span>
<span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="nb">p</span> <span class="n">msg</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">wait</span></code></pre>
</figure>

<p>В приведенных примерах использовалась передача данных только в одну сторону, что, конечно, необязательно. Можно создавать
произвольное количество каналов и назначать их как выводу, так и вводу.</p>

<h3 id="сокеты">Сокеты</h3>

<p>Сокеты — это совсем универсальный механизм взаимодействия произвольных программ между собою, в том числе и по сети.
Здесь уже не важно, как и где запускается процесс-собеседник, нужно только знать адрес и протокол обмена (формат данных).
Сам по себе стандарт сокетов довольно низкоуровневый, так что подробное описание и примеры заняли бы слишком много места.
Отмечу лишь, что инструменты работы с сокетами находятся в модуле <code class="language-plaintext highlighter-rouge">socket</code> стандартной библиотеки.</p>

<p>Кроме того, на сокетах основано взаимодействие уже максимального уровня — готовыми ruby-объектами в библиотеке dRuby,
о которой я писал в одной из предыдущих статей<sup id="fnref:druby"><a href="#fn:druby" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>. Здесь же стоит сказать, что dRuby позволяет обращаться к объекту
в другом процессе (и, возможно, на другой машине) как к локальному объекту Ruby со всеми его методами, свойствами и т.д.</p>

<h2 id="применение">Применение</h2>

<p>Подведем некоторые итоги.</p>

<p>При использовании <em>потоков</em> мы остаемся в рамках одного процесса, что определяет как плюсы, так и минусы: с одной стороны,
возможность использования общих переменных, с другой — взаимная зависимость. Дополнительный минус именно ruby-реализации —
глобальный блокировщик, из-за которого реально в любой момент времени выполняется только один поток. Следует однако понимать,
что GIL — это именно особенность реализации, а не языка, независимые реализации, такие как, например JRuby и Rubinius его
не имеют; не исключено, что и будущие версии «эталонного» Ruby изменят свое поведение.</p>

<p>Оптимальный сценарий использования — распараллеливание ожидания: работа с сетью, фоновые действия когда один из потоков ждет
и обрабатывает общение с пользователем, файловые операции. Основным средством взаимодействия между потоками является
использование общих переменных (не забывая про синхронизацию).</p>

<p>При запуске нескольких <em>процессов</em> получаем полный паралеллизм, а вот средства коммуникации приходится прописывать отдельно.</p>

<p>Соответственно, лучше всего такой сценарий поведет себя на максимально независимых задачах, малосвязных, обмен данными между
которыми можно свести к нескольким точкам. Взаимодействие строится на каналах ввода-вывода для дочерних процессов
и сокетах/dRuby для независимых.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:gist">
      <p>Полные тексты примеров находятся по адресу <a href="https://gist.github.com/shikhalev/9198544">https://gist.github.com/shikhalev/9198544</a>. <a href="#fnref:gist" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:context">
      <p>О блоках и замыканиях см. статью <a href="/2015/04/ruby-context.html">«Блоки и контекст в Ruby»</a> в номере 1-2 этого года. <a href="#fnref:context" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:stdlib">
      <p>Подробную документацию на стандартную библиотеку можно найти по адресу <a href="http://rubydoc.info/stdlib/">http://rubydoc.info/stdlib/</a> (англ.) <a href="#fnref:stdlib" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:druby">
      <p><a href="/2015/03/druby.html">«Распределенный Ruby»</a> в декабрьском номере 2013 года. <a href="#fnref:druby" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Иван Шихалев</name></author><category term="[&quot;tech&quot;, &quot;programming&quot;, &quot;ruby&quot;, &quot;pub&quot;, &quot;samag&quot;]" /><category term="многопоточность" /><category term="оптимизация" /><category term="многозадачность" /><summary type="html"><![CDATA[В статье рассматриваются основные средства работы с потоками (threads) и процессами в языке и стандартной библиотеке Ruby.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://shikhalev.github.io/img/2015/04/04/ruby-multitasking/screen-multitask-640x640-500-261-0-0.webp" /><media:content medium="image" url="https://shikhalev.github.io/img/2015/04/04/ruby-multitasking/screen-multitask-640x640-500-261-0-0.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Блоки и контекст в Ruby</title><link href="https://shikhalev.github.io/2015/04/ruby-context.html" rel="alternate" type="text/html" title="Блоки и контекст в Ruby" /><published>2015-04-01T00:00:00+00:00</published><updated>2015-04-01T00:00:00+00:00</updated><id>https://shikhalev.github.io/2015/04/ruby-context</id><content type="html" xml:base="https://shikhalev.github.io/2015/04/ruby-context.html"><![CDATA[<p><a href="http://samag.ru/archive/article/2622">Оригинал этой статьи опубликован в журнале «Системный администратор» №1–2 (134–135) за январь–февраль 2014</a>.</p>

<hr />

<figure class="__figure __implicit_figure __right" style="max-width:158px;padding: 5px;"><a href="http://samag.ru/archive/article/2622"><img src="/img/2015/04/01/ruby-context/134-5-158.webp" class="__image" /></a></figure>

<div class="note">
  <p><strong>Что стоит за конкретным идентификатором в данном окружении</strong></p>

  <p>Давайте разберемся с программным контекстом в Ruby: какие переменные и другие объекты доступны в конкретном месте
программы, и как интерпретатор их ищет? Что обозначает конкретный идентификатор, откуда он берется? Почему отсюда,
а не оттуда? И чему, наконец, в этом трижды перекинутом блоке будет равен <code class="language-plaintext highlighter-rouge">self</code>?</p>

  <p>Ruby очень гибок и позволяет переопределить так много, что, образно выражаясь, вы можете выстрелить себе в ногу
из самой этой ноги. Картечью.</p>
</div>

<!--more-->

<p>В программировании, неважно на каком языке, есть такое понятие — <em>контекст выполнения</em> — если мы не работаем исключительно
с глобальными переменными, важно понимать, какие локальные объекты доступны и задействованы в каждой конкретной точке
программы. Это достаточно просто для понимания, хотя и важно, в случае объектно-ориентированных языков, дизайн которых
направлен на то, чтобы максимально изолироваться от глобального окружения и работать внутри одного объекта; и несколько
сложнее, но еще более важно, в случаях, когда язык поддерживает <em>замыкания</em> — по сути вынесение кода вместе с его контекстом
куда-то в другое место.</p>

<p>На самом деле, никакой особой магии (по крайней мере, в случае Ruby) тут нет, и правила, определяющие работу с контекстом,
довольно просты, а главное — логичны. Однако их надо знать и понимать очень четко, поскольку вариантов использования очень
много, а кроме того, в языке есть способы переопределить поведение по умолчанию. Кроме того, <em>блоки</em>, образующие замыкания,
в Ruby очень удобны и используются постоянно. При этом переменные не требуют отдельного объявления (подобного <code class="language-plaintext highlighter-rouge">var</code> в других
языках), а определяются в момент инициализации — первого присваивания значения. Все это может привести к недопониманию
и кажущейся неоднозначности.</p>

<h2 id="из-чего-состоит-контекст">Из чего состоит контекст?</h2>

<p>В Ruby в любой точке программы мы имеем доступ к трем слоям контекста: локальный контекст, контекст объекта и глобальный.
Рассмотрим их, так сказать, сверху вниз — от глобального к локальному.</p>

<p>В <em>глобальном контексте</em>, строго говоря, находятся только глобальные переменные — это те, имена которых начинаются с символа
«<code class="language-plaintext highlighter-rouge">$</code>». Однако, мы же можем обращаться к другим элементам — константам, методам — находясь как бы в чисто глобальном окружении —
непосредственно в тексте исходного файла вне всяких <code class="language-plaintext highlighter-rouge">class</code> и <code class="language-plaintext highlighter-rouge">def</code>? Можем, но только потому, что на самом деле находимся
в неявном безымянном методе неявного объекта <code class="language-plaintext highlighter-rouge">main</code>. А «глобальные» константы и методы на самом деле принадлежат классу <code class="language-plaintext highlighter-rouge">Object</code>,
к которому относится и <code class="language-plaintext highlighter-rouge">main</code> (поскольку от этого класса наследуются все остальные, его элементы и доступны в любом контексте).</p>

<p class="note">Строго говоря, начиная с Ruby 1.9, это не совсем так — существует класс <code class="language-plaintext highlighter-rouge">BasicObject</code>, являющийся не наследником,
а предком <code class="language-plaintext highlighter-rouge">Object</code>. Если мы для каких-то целей унаследуемся непосредственно от него, то внезапно обнаружим, что нам очень мало,
чего доступно. Но так делать имеет смысл только в очень специфических задачах, на грани «хака».</p>

<p><em>Контекст объекта</em> позволяет нам обращаться к его методам и константам класса без указания самого объекта, а также к его
переменным экземпляра с префиксом «<code class="language-plaintext highlighter-rouge">@</code>» и переменным класса с «<code class="language-plaintext highlighter-rouge">@@</code>». Сам же текущий объект мы всегда можем получить
посредством ключевого слова «<code class="language-plaintext highlighter-rouge">self</code>».</p>

<p>Наконец, <em>локальный контекст</em> — это все локальные переменные заданные выше по тексту в рамках текущего метода.</p>

<p>Одна из особенностей Ruby — то, что принадлежность идентификатора тому или иному контексту, как правило, можно определить
и не просматривая снизу вверх области видимости — глобальные переменные, переменные экземпляра и класса отличаются префиксами,
имена констант всегда начинаются с большой буквы, а локальных переменных — с маленькой. Некоторую сумятицу вносят только
методы — обладая именами, как у локальных переменных, они принадлежат контексту объекта. Тут действует простое правило:
присваивание создает переменную и перекрывает имя метода. Тем не менее, к нему по прежнему можно обратится посредством
«<code class="language-plaintext highlighter-rouge">self.‹имя›</code>». Стоит заметить, что присваивание всегда создает переменную, даже если у нас ранее определен атрибут,
доступный для присваивания. Т.е. в ситуации<sup id="fnref:gist"><a href="#fn:gist" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="nb">attr_accessor</span> <span class="ss">:alpha</span>

  <span class="k">def</span> <span class="nf">beta</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">alpha</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre>
</figure>

<p>Атрибут после вызова <code class="language-plaintext highlighter-rouge">beta</code> будет равен единице, поскольку строчка без <code class="language-plaintext highlighter-rouge">self</code> к нему отношения не имеет.</p>

<h2 id="блоки">Блоки</h2>

<p>Блоком в Ruby называется конструкция вида:</p>

<figure class="highlight">
  <pre><code class="language-ruby"><i>‹вызов метода›</i> <span class="k">do</span> |<i>‹аргументы›</i>|
  <i>‹какие-то действия›</i>
<span class="k">end</span></code></pre>
</figure>

<p>или же:</p>

<figure class="highlight">
  <pre><code class="language-ruby"><i>‹вызов метода›</i> { |<i>‹аргументы›</i>| <i>‹какие-то действия›</i> }</code></pre>
</figure>

<p>Это две равнозначные формы записи одного и того же. Вторая обычно используется, когда блок умещается в одну строку.
Вызываемый метод частью блока не является, но необходим — каким-либо другим способом блоки не используются.</p>

<p>Блок в Ruby — очень часто используемая конструкция языка, одна из определяющих, если так можно выразиться, ruby-way.</p>

<p>Выглядит в реальности это примерно так (выводим элементы массива):</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">item</span>
<span class="k">end</span></code></pre>
</figure>

<p>или так (преобразуем массив в массив строк):</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">strs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">to_s</span> <span class="p">}</span></code></pre>
</figure>

<p>С другой стороны — со стороны метода — блок может быть вызван посредством ключевого слова «<code class="language-plaintext highlighter-rouge">yield</code>»:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">do_smth</span>
  <span class="k">if</span> <span class="nb">block_given?</span>
    <span class="k">yield</span> <span class="nb">self</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>Здесь проверка <code class="language-plaintext highlighter-rouge">block_given?</code> нужна, чтобы определить, а был ли собственно передан блок, или метод вызывали без него.</p>

<p>Другой вариант — это объявить специальный параметр, который в теле метода волшебным образом превратится в объект класса
<code class="language-plaintext highlighter-rouge">Proc</code> (и его уже можно будет не только вызвать непосредственно, но и сохранить в переменную или передать в другой метод):</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">do_smth_else</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="vi">@smth</span> <span class="o">=</span> <span class="n">block</span>
  <span class="n">do_smth</span> <span class="o">&amp;</span><span class="n">block</span>
<span class="k">end</span></code></pre>
</figure>

<p>Если же при вызове блок не будет передан, параметр будет равен <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p>В рамках разговора о контекстах важно, что блок образует замыкание, т.е. несмотря на то, что выполняться он будет
где-то там в глубинах вызванного метода, а то и вовсе — будет сохранен, а затем вызван уже совсем в другое время,
в блоке можно обращаться к локальным переменным, доступным в месте его объявления. Но при этом блок еще и образует
собственный контекст: имена его формальных параметров, а так же переменные, впервые инициализированные внутри блока,
снаружи не доступны. Рассмотрим такой пример:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">a</span> <span class="o">=</span> <span class="s1">'INIT'</span>

<span class="k">def</span> <span class="nf">alpha</span>
  <span class="n">a</span> <span class="o">||=</span> <span class="ss">:a</span>
  <span class="nb">p</span> <span class="p">[</span><span class="ss">:alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">define_singleton_method</span> <span class="ss">:beta</span> <span class="k">do</span>
  <span class="n">a</span> <span class="o">||=</span> <span class="ss">:b</span>
  <span class="nb">p</span> <span class="p">[</span><span class="ss">:beta</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="s1">'TEST'</span>

<span class="n">alpha</span>

<span class="n">beta</span></code></pre>
</figure>

<p>Использованный здесь оператор «<code class="language-plaintext highlighter-rouge">||=</code>» выполняет присваивание в том случае, если переменная слева от него логически ложна
(равна <code class="language-plaintext highlighter-rouge">false</code> или <code class="language-plaintext highlighter-rouge">nil</code>), или не определена. Приведенный код должен дать следующий вывод:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo02.rb
<span class="go">[:alpha, :a]
[:beta, "TEST"]</span></code></pre>
</figure>

<p>Как видим, в методе, определенном через «<code class="language-plaintext highlighter-rouge">def</code>», внешняя переменная не видна, а вот метод, созданный из блока, ее видит,
поскольку она попала в замыкание. Если же мы закомментируем первую строчку примера, то на момент определения <code class="language-plaintext highlighter-rouge">beta</code> переменная
существовать не будет, соответственно, в замыкание не попадет, и результат будет следующий:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="go">[:alpha, :a]
[:beta, :b]</span></code></pre>
</figure>

<p>Несмотря на то, что присваивание строки «TEST» никуда не делось, оно уже не имеет отношения к той переменной <code class="language-plaintext highlighter-rouge">a</code>, которая
расположена в локальном контексте блока.</p>

<p>Формальные аргументы блока всегда относятся исключительно к его контексту, даже если их имена совпадают с внешними
переменными. В старых версиях Ruby, по 1.8.7 включительно, параметры блока не были изолированы, что вызывало множество
нареканий.</p>

<p>Например, код:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">a</span> <span class="o">=</span> <span class="s1">'A'</span>
<span class="n">b</span> <span class="o">=</span> <span class="s1">'B'</span>

<span class="mi">2</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
  <span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span></code></pre>
</figure>

<p>Выдаст следующее:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo03.rb
<span class="go">[0, 0]
[1, 1]
["A", 1]</span></code></pre>
</figure>

<p>Здесь можно видеть, что переменная <code class="language-plaintext highlighter-rouge">a</code> изолирована в блоке, тогда как <code class="language-plaintext highlighter-rouge">b</code> — нет.</p>

<p>Что же касается контекста объекта, то он, как и локальный, попадает в замыкание, т.е. соответствует месту объявления блока,
если метод, которому передан блок, не подразумевает иное (как, в частности, <code class="language-plaintext highlighter-rouge">define_singleton_method</code>). К методам, изменяющим
контекст, мы еще вернемся, а сейчас рассмотрим подробнее контекст объекта как таковой.</p>

<h2 id="контекст-объекта">Контекст объекта</h2>

<p>Как уже говорилось выше, в Ruby мы всегда действуем в контексте некоего объекта, причем доступные методы полностью определяются
его классом. Но, в общем случае, это не тот класс, который был использован при создании объекта и возвращается методом <code class="language-plaintext highlighter-rouge">class</code>,
а «персональный» класс, присущий только данному объекту и никому более — наследник его «номинального» класса. Чтобы получить этот
«персональный» класс, используется метод <code class="language-plaintext highlighter-rouge">singleton_class</code>.</p>

<p>Пример, демонстрирующий вышесказанное:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="k">def</span> <span class="nf">alpha</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>

<span class="n">a</span><span class="p">.</span><span class="nf">define_singleton_method</span> <span class="ss">:beta</span> <span class="k">do</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="n">a</span>
<span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="nf">class</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)]</span>
<span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">,</span>
   <span class="n">a</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)]</span>
<span class="nb">p</span> <span class="n">a</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span>
<span class="nb">p</span> <span class="n">a</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">.</span><span class="nf">ancestors</span></code></pre>
</figure>

<p>В результате должен получиться примерно такой вывод:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo04.rb
<span class="go">♯‹Alpha:0x0000000175c140›
[Alpha, [:alpha]]
[♯‹Class:♯‹Alpha:0x0000000175c140››, [:beta]]
[Alpha, Object, Kernel, BasicObject]
[Alpha, Object, Kernel, BasicObject]</span></code></pre>
</figure>

<p>В общем случае при вызове метода происходит его поиск сначала в «персональном» классе объекта, а затем в классах и модулях,
список которых выдается методом <code class="language-plaintext highlighter-rouge">ancestors</code> — именно в том порядке, в каком они перечислены. Если оставить одни классы,
получится цепочка наследования, а модули там появляются путем «подмешивания» (в английской терминологии — «mixin») методом
<code class="language-plaintext highlighter-rouge">include</code> (другой вариант добавления «примесей» — <code class="language-plaintext highlighter-rouge">extend</code> — полностью соответствует <code class="language-plaintext highlighter-rouge">include</code>, выполненному для синглтон-класса).
В примере выше можно видеть модуль <code class="language-plaintext highlighter-rouge">Kernel</code>, подмешанный в класс <code class="language-plaintext highlighter-rouge">Object</code>.</p>

<p>Что касается переменных, то в данном контексте имеются, во-первых, <em>переменные объекта</em>, чьи имена начинаются с символа «<code class="language-plaintext highlighter-rouge">@</code>».
С ними все просто, поскольку они принадлежат конкретному экземпляру и больше ниоткуда не доступны. Есть, правда, еще методы
<code class="language-plaintext highlighter-rouge">instance_variable_get</code>, <code class="language-plaintext highlighter-rouge">_set</code> и т.д., но, будучи, как и всякие методы, применяемы к конкретному объекту, они не вносят
дополнительной путаницы.</p>

<p>Несколько интересней с <em>переменными класса</em> — это те, чьи имена начинаются с «<code class="language-plaintext highlighter-rouge">@@</code>». Во-первых, их следовало бы назвать
переменными модуля, поскольку в модулях они ведут себя так же, как и в классах. Во-вторых, они наследуются, т.е. если где-то
в цепочке <code class="language-plaintext highlighter-rouge">ancestors</code> уже была объявлена переменная с таким именем, будет использоваться именно она, а не создана новая
для текущего класса. И это довольно важный момент, поскольку при сложном многоуровневом наследовании одноименные переменные
могут появиться и случайно — тут надо быть внимательным. Наконец, в третьих, эти переменные трактуются по разному, когда
используются в контексте обычного объекта — они считаются относящимися к его классу, и в контексте модуля или класса
(а это ведь с точки зрения Ruby тоже объект) — тогда они относятся непосредственно к нему.</p>

<p>Небольшой пример, где мы инициализируем переменную в контексте класса, изменяем ее в контексте экземпляра этого класса,
а затем еще раз изменяем в контексте класса-наследника:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="vc">@@alpha</span> <span class="o">=</span> <span class="s1">'A'</span>

  <span class="k">def</span> <span class="nc">Alpha</span><span class="o">.</span><span class="nf">alpha</span>
    <span class="vc">@@alpha</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">set_alpha</span> <span class="n">x</span>
    <span class="vc">@@alpha</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>
<span class="n">a</span><span class="p">.</span><span class="nf">set_alpha</span> <span class="s1">'X'</span>

<span class="nb">p</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">alpha</span>

<span class="k">class</span> <span class="nc">Beta</span> <span class="o">&lt;</span> <span class="no">Alpha</span>
  <span class="vc">@@alpha</span> <span class="o">=</span> <span class="s1">'B'</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">alpha</span></code></pre>
</figure>

<p>Во всех случаях мы имеем дело с одной и той же переменной и, соответственно, получаем ожидаемый вывод:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo06.rb
<span class="go">"X"
"B"</span></code></pre>
</figure>

<h2 id="константы-и-пространства-имен">Константы и пространства имен</h2>

<p>Константы в Ruby отличаются от всего остального заглавной первой буквой. Имена классов и модулей — это тоже константы,
значением которых является соответствующий объект класса <code class="language-plaintext highlighter-rouge">Class</code> или <code class="language-plaintext highlighter-rouge">Module</code>.</p>

<p>Константы в чем-то подобны переменным класса, только доступны снаружи (посредством «<code class="language-plaintext highlighter-rouge">::</code>»), и повторное присваивание
им значения выдает предупреждение. Есть и еще два существенных отличия.</p>

<p>Первое — если в классе-предке и классе-потомке имеются одноименные константы, то это разные константы, т.е. переопределение
задает новую константу для потомка, а не затирает значение в предке. Второй же момент — это то, что к поиску «по предкам»
добавляется такая вещь как пространства имен.</p>

<p>В принципе, пространства имен в Ruby понять достаточно просто: имена классов и модулей представляют собой константы,
при этом классы и модули сами могут содержать константы, в том числе, правильно, другие классы и модули. Выглядит это
примерно так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="k">class</span> <span class="nc">Beta</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">b</span> <span class="o">=</span> <span class="no">Alpha</span><span class="o">::</span><span class="no">Beta</span><span class="p">.</span><span class="nf">new</span></code></pre>
</figure>

<p>Так вот, если где-то в классе <code class="language-plaintext highlighter-rouge">Beta</code> обратиться к константе, после собственного класса, интерпретатор будет ее искать во внешнем
классе — <code class="language-plaintext highlighter-rouge">Alpha</code>. И даже более того — такой вложенный поиск более приоритетен, чем поиск по цепочке наследования. Немного
парадоксальный пример:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="no">ALPHA</span> <span class="o">=</span> <span class="s1">'A'</span>

<span class="k">end</span>

<span class="k">module</span> <span class="nn">Beta</span>

  <span class="no">ALPHA</span> <span class="o">=</span> <span class="s1">'B'</span>

  <span class="k">class</span> <span class="nc">Gamma</span> <span class="o">&lt;</span> <span class="no">Alpha</span>

    <span class="k">def</span> <span class="nc">Gamma</span><span class="o">.</span><span class="nf">alpha</span>
      <span class="no">ALPHA</span>
    <span class="k">end</span>

  <span class="k">end</span>

<span class="k">end</span>

<span class="nb">p</span> <span class="no">Beta</span><span class="o">::</span><span class="no">Gamma</span><span class="p">.</span><span class="nf">alpha</span>
<span class="nb">p</span> <span class="no">Beta</span><span class="o">::</span><span class="no">Gamma</span><span class="o">::</span><span class="no">ALPHA</span></code></pre>
</figure>

<p>Выдаст, невзирая на здравый смысл, два разных значения:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo07.rb
<span class="go">"B"
"A"</span></code></pre>
</figure>

<p>Т.е. в первом случае найдена ближайшая внешняя константа, а во втором — ближайшая унаследованная… Что с этим делать?
Могу порекомендовать только одно: в сложных случаях не рассчитывать на определенное поведение интерпретатора — оно-то
определено и стабильно (вышеприведенный код я проверил на версиях 1.8, 1.9, 2.0 и 2.1), но не всегда очевидно разработчику
и зависит от способов обращения, которые в течении жизненного цикла кода могут изменяться. В общем, при малейшем подозрении
на неоднозначность, лучше прописывать явно полный идентификатор со всеми «<code class="language-plaintext highlighter-rouge">::</code>». Кстати, к именам верхнего уровня, никуда
не вложенным, можно обратиться так: «<code class="language-plaintext highlighter-rouge">::Object</code>» или «<code class="language-plaintext highlighter-rouge">::Kernel</code>» — это всегда будет работать правильно, что бы ни было
одноименное определено в том контексте, где находится вызов. Ну и, конечно, не стоит злоупотреблять пространствами имен
и переопределением уже использованных идентификаторов. Как и любыми другими возможностями языка: Ruby очень гибок и позволяет
переопределить так много, что, образно выражаясь, вы можете выстрелить себе в ногу из самой этой ноги. Картечью.</p>

<h2 id="замена-контекста">Замена контекста</h2>

<p>Локальный контекст, равно как и контекст объекта, может быть указан явно. Для этого существует несколько разнородных техник,
о которых мы сейчас и поговорим.</p>

<p>Начнем с простого и прозрачного — явного указания объекта. Для этой цели служат методы <code class="language-plaintext highlighter-rouge">instance_eval</code> и <code class="language-plaintext highlighter-rouge">instance_exec</code>,
немного различающиеся между собой синтаксисом. Они позволяют выполнить блок в контексте заданного объекта. При этом блок
остается замыканием, т.е. локальный контекст он захватывает свой. Пример:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>
  <span class="nb">attr_accessor</span> <span class="ss">:alpha</span>
<span class="k">end</span>

<span class="n">alpha</span> <span class="o">=</span> <span class="s1">'a'</span>
<span class="n">x</span> <span class="o">=</span> <span class="s1">'x'</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>
<span class="n">a</span><span class="p">.</span><span class="nf">alpha</span> <span class="o">=</span> <span class="s1">'A'</span>

<span class="n">a</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="k">do</span>
  <span class="nb">p</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">self</span><span class="p">]</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">alpha</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span></code></pre>
</figure>

<p>Выдаст примерно следующее:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo08.rb
<span class="go">["a", "x", ♯‹Alpha:0x0000000107bb50 @alpha="A"›]
["a", "x", ♯‹Alpha:0x0000000107bb50 @alpha="x"›]</span></code></pre>
</figure>

<p>А если мы перенесем присвоение значения переменной <code class="language-plaintext highlighter-rouge">alpha</code> в строчку сразу за блоком, то получим:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="go">["A", "x", ♯‹Alpha:0x0000000213bad0 @alpha="A"›]
["a", "x", ♯‹Alpha:0x0000000213bad0 @alpha="x"›]</span></code></pre>
</figure>

<p>Таким образом видно, что идентификатор сначала ищется в замыкании, а если его там нет — в методах объекта.</p>

<p>Для классов и модулей есть методы <code class="language-plaintext highlighter-rouge">module_eval</code> и <code class="language-plaintext highlighter-rouge">module_exec</code> (существуют также методы <code class="language-plaintext highlighter-rouge">class_eval</code> и <code class="language-plaintext highlighter-rouge">class_exec</code>,
являющиеся полными синонимами <code class="language-plaintext highlighter-rouge">module_xxx</code>.), которые отличаются от <code class="language-plaintext highlighter-rouge">instance</code>-методов семантикой определения методов.
Внутри <code class="language-plaintext highlighter-rouge">instance_eval</code> конструкция «<code class="language-plaintext highlighter-rouge">def</code>» определяет синглтон-метод, независимо от того, является ли объект модулем/классом,
или нет; в случае <code class="language-plaintext highlighter-rouge">module_eval</code> она определяет метод экземпляра. То есть:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>
<span class="k">end</span>

<span class="no">Alpha</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">alpha</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Alpha</span><span class="p">.</span><span class="nf">module_eval</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">beta</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="p">[</span><span class="no">Alpha</span><span class="p">.</span><span class="nf">methods</span><span class="p">(</span><span class="kp">false</span><span class="p">),</span>
   <span class="no">Alpha</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)]</span></code></pre>
</figure>

<p>Нам покажет:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo09.rb
<span class="go">[[:alpha], [:beta]]</span></code></pre>
</figure>

<p>Схожим образом формируется контекст при определении методов из блоков посредством <code class="language-plaintext highlighter-rouge">define_method</code>, или <code class="language-plaintext highlighter-rouge">define_singleton_method</code>.
И это зачастую очень удобный способ создавать методы, опирающиеся на замыкания. Как-то так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="k">def</span> <span class="nf">name_method</span> <span class="nb">name</span>
    <span class="n">define_singleton_method</span> <span class="nb">name</span> <span class="k">do</span>
      <span class="s2">"name: </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>

<span class="n">a</span><span class="p">.</span><span class="nf">name_method</span> <span class="ss">:alpha</span>
<span class="n">a</span><span class="p">.</span><span class="nf">name_method</span> <span class="ss">:beta</span>

<span class="nb">p</span> <span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="nf">alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="nf">beta</span><span class="p">]</span></code></pre>
</figure>

<p>С результатом:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo10.rb
<span class="go">["name: alpha", "name: beta"]</span></code></pre>
</figure>

<p>Что же касается локального контекста, с ним сложнее. Нельзя, скажем, взять и выполнить блок в чужом локальном контексте,
однако можно сохранить некий контекст и выполнить в нем код, представленный в виде строки. Для этого используется метод
<code class="language-plaintext highlighter-rouge">binding</code>, возвращающий объект класса <code class="language-plaintext highlighter-rouge">Binding</code>. Выглядит это примерно так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">get_binding</span>
  <span class="n">local</span> <span class="o">=</span> <span class="mi">100</span>
  <span class="k">return</span> <span class="nb">binding</span>
<span class="k">end</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">get_binding</span>

<span class="n">b</span><span class="p">.</span><span class="nf">eval</span> <span class="s1">'p local'</span></code></pre>
</figure>

<p>Если быть точным, то объект класса <code class="language-plaintext highlighter-rouge">Binding</code> хранит не только локальный контекст, но и объектный — это полный контекст
в той точке, где был вызван метод <code class="language-plaintext highlighter-rouge">binding</code>. С учетом того, что выполнение кода из строки — процесс довольно медленный
(по сравнению с нормальным, предварительно разобранным кодом), использовать эту технику как-либо, кроме как в отладке,
наверное, не стоит. С другой стороны, локальный контекст на то и локальный, чтобы не заботиться о нем снаружи.</p>

<h2 id="замыкания-и-многозадачность">Замыкания и многозадачность</h2>

<p>Если мы пишем многопоточную программу, надо помнить, что замыкания содержат переменные, а не их значения. Т.е. значения
могут поменяться со времени старта потока.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">a</span> <span class="o">=</span> <span class="ss">:start</span>

<span class="n">t</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="nb">sleep</span> <span class="mi">1</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">exclusive</span> <span class="p">{</span> <span class="nb">p</span> <span class="n">a</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="ss">:continue</span>

<span class="n">t</span><span class="p">.</span><span class="nf">join</span></code></pre>
</figure>

<p>Выдаст <code class="language-plaintext highlighter-rouge">:continue</code>, а не <code class="language-plaintext highlighter-rouge">:start</code>. И не забываем оборачивать обращения к внешним переменным в блок метода <code class="language-plaintext highlighter-rouge">exclusive</code>
во избежание конфликтов. В данном примере, конечно, можно без него обойтись, но только потому, что ничего полезного
в нем и не делается.</p>

<p>Другая картина в случае, если мы захотим использовать дочерний процесс — в этом случае мы получим полную копию всего,
включая глобальный контекст, и никаких общих переменных — для обмена данными между процессами используются уже совсем
другие средства, например, dRuby<sup id="fnref:druby"><a href="#fn:druby" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>. Т.е.:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="vg">$a</span> <span class="o">=</span> <span class="ss">:start</span>

<span class="nb">fork</span> <span class="k">do</span>
  <span class="nb">sleep</span> <span class="mi">1</span>
  <span class="nb">p</span> <span class="vg">$a</span>
<span class="k">end</span>

<span class="vg">$a</span> <span class="o">=</span> <span class="ss">:continue</span>

<span class="no">Process</span><span class="p">.</span><span class="nf">wait</span></code></pre>
</figure>

<p>Выдаст нам все-таки <code class="language-plaintext highlighter-rouge">:start</code>, именно это значение будет скопировано в момент форка вместе со всем остальным.</p>

<p>Вообще говоря, сказанное в этом разделе довольно очевидно для программистов, представляющих себе управление потоками и
процессами как таковое, однако скриптовые языки, и Ruby в частности, нередко используют люди, в недавнем прошлом далекие
от программирования… А задач, которые можно распараллелить — множество, тем более, что в Ruby это очень просто.</p>

<h2 id="итого">Итого</h2>

<p>Надеюсь, понимание вышеизложенного поможет избегать ошибок при написании программ. Впрочем, еще важнее это понимание
при чтении чужих исходников — чтобы не возникало вопросов: а что у нас тут обозначает этот идентификатор, откуда он берется?
А почему именно отсюда, а не оттуда? И чему, наконец, в этом трижды перекинутом между разными методами блоке будет равен <code class="language-plaintext highlighter-rouge">self</code>?..</p>

<p>Отдельно хотелось бы сказать: несмотря на то, что поведение интерпретатора всегда однозначно и для большинства случаев
стабильно от версии к версии, лучше избегать неочевидностей — человеческий мозг не компьютер и может долго «не замечать»,
что какой-то нужный идентификатор оказался перекрыт другим, или что вместо переменной объекта используется переменная класса, и т.д.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:gist">
      <p>Полные тексты примеров — <a href="https://gist.github.com/shikhalev/8301163">https://gist.github.com/shikhalev/8301163</a>. <a href="#fnref:gist" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:druby">
      <p>Шихалев И. <a href="/2015/03/druby.html">Распределенный Ruby</a>. Прозрачный RPC для взаимодействия Ruby-программ // Системный администратор, №12(133), 2013г., — С. 58—61 <a href="#fnref:druby" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Иван Шихалев</name></author><category term="[&quot;tech&quot;, &quot;programming&quot;, &quot;ruby&quot;, &quot;pub&quot;, &quot;samag&quot;]" /><category term="контекст" /><category term="замыкания" /><summary type="html"><![CDATA[Статья рассказывает о программном контексте в Ruby: какие переменные и другие объекты доступны в конкретном месте программы, и как интерпретатор их ищет.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://shikhalev.github.io/img/2015/04/01/ruby-context/screen-context-640x640-500-261-0-0.webp" /><media:content medium="image" url="https://shikhalev.github.io/img/2015/04/01/ruby-context/screen-context-640x640-500-261-0-0.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Распределенный Ruby</title><link href="https://shikhalev.github.io/2015/03/druby.html" rel="alternate" type="text/html" title="Распределенный Ruby" /><published>2015-03-31T00:00:00+00:00</published><updated>2015-03-31T00:00:00+00:00</updated><id>https://shikhalev.github.io/2015/03/druby</id><content type="html" xml:base="https://shikhalev.github.io/2015/03/druby.html"><![CDATA[<p><a href="http://samag.ru/archive/article/2592">Оригинал этой статьи опубликован в журнале «Системный администратор» №12 (133) за декабрь 2013</a>.</p>

<hr />

<figure class="__figure __implicit_figure __right" style="max-width:158px;padding: 5px;"><a href="http://samag.ru/archive/article/2592"><img src="/img/2015/03/31/druby/133-158.webp" class="__image" /></a></figure>

<div class="note">
  <p>Технология распределенного Ruby, или <strong>dRuby</strong> (Dis­­t­­ri­­bu­­ted Ruby), позволяет вызывать методы объектов, находящихся
в другом процессе и/или на другом компьютере. При этом установка соединения, передача необходимых данных и тому
подобное — скрыты от программиста, и использование удаленных объектов мало чем отличается от работы с объектами,
заданными внутри программы.</p>

  <p>Это не единственная технология RPC, доступная при про­­г­­рам­­ми­­ро­­ва­­нии на Ruby, однако более универсальные средства,
такие как CORBA или XML-RPC, более сложны в использовании и требуют бо́льших накладных расходов (кроме того, поддержка
CORBA не входит в стандартную библиотеку Ruby, соответственно, в сопровождении требует дополнительного внимания
к совместимости версий и т.д.). В общем, если не требуется взаимодействие с программами, написанными на других языках,
dRuby — очень хороший выбор, а с чем его едят и как правильно готовить, мы и рассмотрим в данной статье.</p>
</div>

<!--more-->

<hr style="clear: both;" />

<div class="sticker right" style="max-width:300px;">
  <p><u>RPC</u> — Remote Procedure Call — общее название для технологий, позволяющих программам вызывать процедуры/функции
в чужом адресном пространстве, в том числе — на другом компьютере. По особенностям использования и реализации
эти технологии между собой очень сильно различаются.</p>

  <p>Из наиболее популярных можно отметить архитектуру <em>CORBA</em>, разрабатываемую рабочей группой OMG, и протокол <em>DCOM</em>,
принадлежащий Microsoft (и работающий де-факто только в Windows), а также текстовые протоколы, работающие поверх
HTTP — <em>JSON-RPC</em> и <em>XML-RPC</em>.</p>

  <p>Ruby «из коробки», т.е. в рамках стандартной библиотеки, поддерживает, помимо собственной технологии dRuby,
только XML-RPC. Тем не менее, можно найти и установить гемы для CORBA и JSON-RPC — r2corba и json-rpc-objects
соответственно.</p>
</div>

<p>Технология распределенного Ruby, или <strong>dRuby</strong> (Dis­­t­­ri­­bu­­ted Ruby), позволяет вызывать методы объектов, находящихся
в другом процессе и/или на другом компьютере. При этом установка соединения, передача необходимых данных и тому
подобное — скрыты от программиста, и использование удаленных объектов мало чем отличается от работы с объектами,
заданными внутри программы.</p>

<p>Это не единственная технология RPC, доступная при про­­г­­рам­­ми­­ро­­ва­­нии на Ru­by, однако более универсальные средства,
такие как CORBA или XML-RPC, более сложны в использовании и требуют бо́льших накладных расходов (кроме того, поддержка
CORBA не входит в стандартную библиотеку Ruby, соответственно, в сопровождении требует дополнительного внимания
к совместимости версий и т.д.). В общем, если не требуется взаимодействие с программами, написанными на других языках,
dRuby — очень хороший выбор, а с чем его едят и как правильно готовить, мы и рассмотрим в данной статье.</p>

<h2 id="минимальный-пример">Минимальный пример</h2>

<p>Рассмотрим код<sup id="fnref:gist"><a href="#fn:gist" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> простейшего сервера:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'drb'</span>

<span class="k">class</span> <span class="nc">Server</span>

  <span class="k">def</span> <span class="nf">alpha</span> <span class="n">arg</span>
    <span class="nb">puts</span> <span class="s2">"Alpha called with </span><span class="si">#{</span><span class="n">arg</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
    <span class="p">[</span><span class="ss">:alpha</span><span class="p">,</span> <span class="n">arg</span><span class="p">]</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="no">DRb</span><span class="p">.</span><span class="nf">start_service</span> <span class="s1">'druby://localhost:9000'</span><span class="p">,</span> <span class="no">Server</span><span class="p">.</span><span class="nf">new</span>

<span class="no">DRb</span><span class="p">.</span><span class="nf">thread</span><span class="p">.</span><span class="nf">join</span></code></pre>
</figure>

<p>Как видим, ничего особенного делать не приходится — берем самый обыкновенный объект и запускаем сервис, выставляющий
его на определенный адрес и порт. Последняя строка заставляет программу дожидаться завершения нити-обработчика запросов;
в реальном проекте нам потребуется определить какой-то способ корректного завершения — с сохранением данных, еще какими-то
действиями… Но это имеет лишь опосредованное отношение к теме статьи, поэтому перегружать пример не будем. Поскольку
запускать сервер мы будем из консоли, для завершения достаточно использовать сочетание клавиш <code class="language-plaintext highlighter-rouge">Ctrl-C</code>.</p>

<p>И клиента:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'drb'</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">DRbObject</span><span class="p">.</span><span class="nf">new</span> <span class="kp">nil</span><span class="p">,</span> <span class="s1">'druby://localhost:9000'</span>

<span class="nb">p</span> <span class="n">a</span><span class="p">.</span><span class="nf">alpha</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">p</span> <span class="n">a</span><span class="p">.</span><span class="nf">alpha</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span>
<span class="nb">p</span> <span class="n">a</span><span class="p">.</span><span class="nf">alpha</span><span class="p">(</span><span class="s2">"beta"</span><span class="p">)</span></code></pre>
</figure>

<p>Здесь тоже ничего особенного — создаем специальный объект-посредник и обращаемся с ним, как с тем объектом,
который мы создали на сервере.</p>

<p>Запустим в одной консоли сервер, в другой клиент, получим:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby 01_c.rb
<span class="go">[:alpha, 1]
[:alpha, nil]
[:alpha, "beta"]</span></code></pre>
</figure>

<p>Кроме того, вернувшись в консоль сервера, видим:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="go">Alpha called with 1
Alpha called with nil
Alpha called with "beta"</span></code></pre>
</figure>

<p>Что свидетельствует о выполнении метода именно на той стороне.</p>

<h2 id="передача-данных">Передача данных</h2>

<p>Уже из вышеприведенного можно видеть, что обмен данными простых стандартных классов происходит полностью прозрачно —
мы использовали число, строку, <code class="language-plaintext highlighter-rouge">nil</code> и массив — все они выглядят на стороне клиента и сервера совершенно одинаково.
А что произойдет, если мы будем передавать нестандартные, определенные нами же объекты? Попробуем — определим класс
на сервере:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="k">def</span> <span class="nf">dummy</span>
    <span class="ss">:dummy</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="k">class</span> <span class="nc">Server</span>

  <span class="k">def</span> <span class="nf">alpha</span>
    <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre>
</figure>

<p>И попытаемся обратиться к нему на клиенте:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">s</span> <span class="o">=</span> <span class="no">DRbObject</span><span class="p">.</span><span class="nf">new</span> <span class="kp">nil</span><span class="p">,</span> <span class="s1">'druby://localhost:9000'</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">alpha</span>
<span class="nb">p</span> <span class="n">a</span>
<span class="nb">p</span> <span class="n">a</span><span class="p">.</span><span class="nf">dummy</span></code></pre>
</figure>

<p>Результат нас немного огорчит:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby 02_c.rb
<span class="go">♯‹DRb::DRbUnknown:0x000000007ff788 @name="Alpha", @buf="\x04\bo:\nAlpha\x00"›
cln1.rb:11:in `‹main›': undefined method `dummy' for ♯‹DRb::DRbUnknown:0x000000007ff788› (NoMethodError)</span></code></pre>
</figure>

<p>Т.е. мы получили некий неизвестный объект, с которым клиентская сторона не знает, что делать. С другой стороны,
это логично — откуда же ей знать?.. Однако, никаких проблем не возникнет, если мы определим класс объекта и там и там.
Лучше всего сделать это в отдельном файле, который подключается через <code class="language-plaintext highlighter-rouge">require</code>.</p>

<p>Но, вообще говоря, откуда Ruby знать, что некий класс на сервере и одноименный класс на клиенте — это одно и то же?
А никто этого и не обещает. В действительности это могут быть совершенно разные классы, нужно лишь соблюдать совместимость
по маршалингу — это встроенный механизм Ruby для сохранения/восстановления произвольных значений. В простых случаях
о его работе задумываться не приходится — по умолчанию при маршализации объекта просто маршализуются и сохраняются его
внутренние переменные, но могут быть и случаи сложные:</p>

<ul>
  <li>
    <p>Объект наследует/использует немаршализуемые объекты, плотно связанные с текущим окружением — <code class="language-plaintext highlighter-rouge">Proc</code>, <code class="language-plaintext highlighter-rouge">IO</code> и так далее.</p>
  </li>
  <li>
    <p>Класс объекта определен во внешней бинарной библиотеке, и Ruby ничего не знает о его состоянии.</p>
  </li>
  <li>
    <p>По каким-то причинам классы на клиенте и сервере существенно разные…</p>
  </li>
</ul>

<p>В такой ситуации мы можем определить методы <code class="language-plaintext highlighter-rouge">marshal_dump</code>/<code class="language-plaintext highlighter-rouge">marshal_load</code>, которые будут приводить данные объекта
к какому-нибудь общему знаменателю (например, в виде хэша, содержащего только маршализуемые значения) и, соответственно,
восстанавливать объект по этому значению.</p>

<p>Другой же вариант — наоборот, объявить объект немаршализуемым, в этом случае мы сможем к нему обращаться так же, как
и к объекту-серверу — через объект-посредник класса <code class="language-plaintext highlighter-rouge">DRbObject</code>. Используя библиотеку <code class="language-plaintext highlighter-rouge">drb</code>, проще всего это сделать
включением миксин-модуля <code class="language-plaintext highlighter-rouge">DRbUndumped</code>. Т.е. определив на сервере:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Gamma</span>
  <span class="kp">include</span> <span class="no">DRbUndumped</span>

  <span class="k">def</span> <span class="nf">dummy</span>
    <span class="nb">puts</span> <span class="s1">'Dummy called'</span>
    <span class="ss">:dummy</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="k">class</span> <span class="nc">Server</span>

  <span class="k">def</span> <span class="nf">gamma</span>
    <span class="no">Gamma</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre>
</figure>

<p>И вызвав на клиенте <code class="language-plaintext highlighter-rouge">s.gamma.dummy</code>, мы увидим вывод строки «Dummy called» в серверной, а не клиентской консоли.</p>

<h2 id="клиентская-часть">Клиентская часть</h2>

<p>Несмотря на то, что работа в целом идет по асимметричной схеме клиент-сервер, обмен данными вполне симметричен,
и мы вполне можем передать серверу объект, методы которого будут выполняться на клиенте. Самый простой способ
это продемонстрировать — передать блок (который сам по себе является объектом класса <code class="language-plaintext highlighter-rouge">Proc</code>). Пусть у нас будет
следующий сервер:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Server</span>

  <span class="kp">include</span> <span class="no">DRbUndumped</span>

  <span class="k">def</span> <span class="nf">doSmth</span> <span class="o">&amp;</span><span class="n">block</span>
    <span class="nb">puts</span> <span class="s1">'--- server'</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">call</span> <span class="nb">self</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="no">DRb</span><span class="p">.</span><span class="nf">start_service</span> <span class="s1">'druby://localhost:9000'</span><span class="p">,</span> <span class="no">Server</span><span class="p">.</span><span class="nf">new</span>

<span class="no">DRb</span><span class="p">.</span><span class="nf">thread</span><span class="p">.</span><span class="nf">join</span></code></pre>
</figure>

<p>И соответствующий клиент:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'drb'</span>

<span class="no">DRb</span><span class="p">.</span><span class="nf">start_service</span>
<span class="n">s</span> <span class="o">=</span> <span class="no">DRbObject</span><span class="p">.</span><span class="nf">new</span> <span class="kp">nil</span><span class="p">,</span> <span class="s1">'druby://localhost:9000'</span>

<span class="n">s</span><span class="p">.</span><span class="nf">doSmth</span> <span class="k">do</span> <span class="o">|</span><span class="n">srv</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s1">'--- client'</span>
<span class="k">end</span></code></pre>
</figure>

<p>Запустив всё это, мы убедимся, что строка «— server» выводится в серверной консоли, тогда как «— client» — в клиентской,
как и следовало ожидать.</p>

<p>Тут возник один нюанс — в клиентской части мы использовали, в отличие от предыдущих примеров, вызов <code class="language-plaintext highlighter-rouge">DRb.start_service</code> без параметров.
Это важно, именно эта строчка обеспечивает возможность вызова клиентских методов с сервера.</p>

<p>Здесь возникает вопрос — а можем ли мы как-то передать блок кода серверу, чтобы он выполнил его у себя, в своем контексте?
Вообще говоря, нет — объекты, представляющие код, не маршализуются — ни <code class="language-plaintext highlighter-rouge">Proc</code>, ни <code class="language-plaintext highlighter-rouge">Method</code>. Однако, мы можем заставить сервер
выполнить произвольную строку, для этого нам понадобится следующий хак (на стороне клиента):</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">s</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="s1">'undef :instance_eval'</span>
<span class="n">s</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="s1">'p "client str"'</span></code></pre>
</figure>

<p>Первой строчкой мы удаляем метод <code class="language-plaintext highlighter-rouge">instance_eval</code> объекта-посредника, что заставляет его в дальнейшем передавать вызов серверу,
ну а дальше выполняем произвольную строку… Что плавно подводит нас к следующей теме.</p>

<h2 id="безопасность">Безопасность</h2>

<p>Очевидно, что сервер, работающий по приципу: «ходи, кто хочет, бери, что хочет» — это плохой сервер, и надо бы как-то
это дело ограничить. Начнем со второй части — запретим выполнять произвольный код. Можно, например, поудалять у серверного
объекта все потенциально опасные методы, такие как <code class="language-plaintext highlighter-rouge">instance_eval</code>, но в случае большой и сложной программы отследить их
все будет не так-то просто. Лучше воспользоваться уровнями безопасности Ruby и тем фактом, что метод <code class="language-plaintext highlighter-rouge">start_service</code> имеет
необязательный третий параметр — хэш различных опций, в частности — <code class="language-plaintext highlighter-rouge">:safe_level</code>. Чтобы запретить выполнение произвольной
строки, достаточно выставить его в единицу, и злонамеренный клиент свалится с исключением:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="no">DRb</span><span class="p">.</span><span class="nf">start_service</span> <span class="s1">'druby://localhost:9000'</span><span class="p">,</span> <span class="no">Server</span><span class="p">.</span><span class="nf">new</span><span class="p">,</span>
    <span class="ss">:safe_level</span> <span class="o">=&gt;</span> <span class="mi">1</span></code></pre>
</figure>

<p>Более высокие уровни добавят еще больше ограничений, подробнее см. документацию<sup id="fnref:safe"><a href="#fn:safe" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>. Уровень безопасности можно выставить
и глобально для всей программы через переменную <code class="language-plaintext highlighter-rouge">$SAFE</code>, однако задание его для конкретного сервиса более гибко и, на мой взгляд,
удобно.</p>

<p>Теперь вернемся к «ходи, кто хочет» и ограничим доступ. Здесь подход будет зависеть от того, с кем собственно сервер должен
взаимодействовать. Варианты следующие:</p>

<ul>
  <li>
    <p>Отдельные пользователи на локальной системе (вариант «управление службой», см. далее раздел «Сценарии использования»).</p>
  </li>
  <li>
    <p>Клиенты в локальной сети, параметры которой нам известны.</p>
  </li>
  <li>
    <p>Клиенты в глобальной сети, могут обращаться из заранее неизвестного места.</p>
  </li>
</ul>

<p>В первом случае нам, возможно, имеет смысл использовать не TCP/IP, как во всех примерах выше, а протокол сокетов UNIX (правда,
под Windows этот способ не пройдет). Управление доступом в этом случае производится посредством обычных прав на доступ к файлам.
Запуск сервиса будет выглядеть примерно так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'drb/unix'</span>

<span class="no">DRb</span><span class="p">.</span><span class="nf">start_service</span> <span class="s1">'drbunix:/tmp/mydrb'</span><span class="p">,</span> <span class="no">Server</span><span class="p">.</span><span class="nf">new</span><span class="p">,</span>
    <span class="ss">:UNIXFileMode</span> <span class="o">=&gt;</span> <span class="mo">0660</span></code></pre>
</figure>

<p>Соответственно, смогут подключиться только те клиенты, которые запущены от имени пользователя, входящего в группу сервера.
Кроме <code class="language-plaintext highlighter-rouge">:UNIXFileMode</code> доступны также параметры <code class="language-plaintext highlighter-rouge">:UNIXFileOwner</code> и <code class="language-plaintext highlighter-rouge">:UNIXFileGroup</code>.</p>

<p>В локальной сети (и вообще, если IP-адреса клиентов заранее известны и фиксированы), мы можем воспользоваться расширением ACL,
примерно так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'drb/acl'</span>

<span class="n">acl</span> <span class="o">=</span> <span class="no">ACL</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="sx">%w(
             deny all
             allow localhost
             allow ::1
             allow 192.168.1.*
             )</span><span class="p">)</span>

<span class="no">DRb</span><span class="p">.</span><span class="nf">start_service</span> <span class="s1">'druby://localhost:9000'</span><span class="p">,</span> <span class="no">Server</span><span class="p">.</span><span class="nf">new</span><span class="p">,</span>
     <span class="ss">:tcp_acl</span> <span class="o">=&gt;</span> <span class="n">acl</span></code></pre>
</figure>

<p>В более же общем случае нам придется прибегнуть к шифрованным безопасным соединениям. Здесь есть два пути: ssh-туннель
и соединение через SSL.</p>

<p>Для ssh-туннелирования нам потребуется пробросить пару портов — в прямом и обратном направлениях, а так же установить явно
адрес клиентского сервиса. Серверный код не изменится.</p>

<p>На клиенте в отдельной консоли выполняем:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ssh <span class="nt">-N</span> <span class="nt">-L</span> 9000:127.0.0.1:9000 <span class="se">\</span>
<span class="go">         -R 9001:127.0.0.1:9001 server</span></code></pre>
</figure>

<p>Где «server» — имя или адрес сервера, а в коде клиента пишем:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="no">DRb</span><span class="p">.</span><span class="nf">start_service</span> <span class="s1">'druby://127.0.0.1:9001'</span>
<span class="n">s</span> <span class="o">=</span> <span class="no">DRbObject</span><span class="p">.</span><span class="nf">new</span> <span class="kp">nil</span><span class="p">,</span> <span class="s1">'druby://127.0.0.1:9000'</span></code></pre>
</figure>

<p>Команда <code class="language-plaintext highlighter-rouge">ssh</code> (и, на серверной стороне, служба <code class="language-plaintext highlighter-rouge">sshd</code>) берется из пакета OpenSSH<sup id="fnref:openssh"><a href="#fn:openssh" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>, который стандартен для unix-систем,
но вполне доступен и для Windows. Управление доступом в этом варианте обеспечивается совместно с доступом по протоколу SSH вообще,
что можно считать как преимуществом — используется стандартный инструмент администратора, так и недостатком — отдельный доступ
только для dRuby настроить не получится.</p>

<p>Наиболее гибкая, но и трудоемкая, настройка безопасности возможна при работе через SSL (Secure Socket Layer). Вкратце: соединение
производится по адресу вида «<code class="language-plaintext highlighter-rouge">drbssl://server:port</code>», кроме того, в опциях <code class="language-plaintext highlighter-rouge">start_service</code>, как на сервере, так и на клиенте нужно
передать ключи шифрования и сертификаты, которыми эти ключи подписаны… А еще сами сертификаты должны быть подписаны удостоверяющим
центром и т.д. — по большому счету, эта тема заслуживает отдельного рассмотрения<sup id="fnref:ssl"><a href="#fn:ssl" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p>

<h2 id="сценарии-использования">Сценарии использования</h2>

<p>Итак, с чем же его едят? Что полезного мы можем сделать, используя технологию dRuby?</p>

<p>Во-первых, мы можем создать <em>фоновую службу</em> и, отдельно, управляющую утилиту, убрав таким образом из постоянно загруженной
программы все интерфейсные элементы, при этом обладая максимальной свободой в управлении ею «на ходу».</p>

<p>Во-вторых, через dRuby легко реализуется <em>классическая трехзвенная архитектура</em>, где вся бизнес-логика работает в отдельном
процессе, а приложения, обеспечивающие интерфейс, хоть настольные, хоть формирующие веб-сайт, существуют и разрабатываются
независимо. Причем для разных категорий клиентов мы можем выдавать разные объекты-серверы. Собственно даже само разделение
бизнес-логики и отображения на разные процессы, разные репозитории исходного кода — это уже весьма полезно в плане надежности
и легкости сопровождения.</p>

<p>Ну и, наконец, возможность разрабатывать полностью <em>гетерогенные и многоуровневые системы</em>, элементы которых разнесены
не только в пространстве, но и организационно, и обмениваются не всеми имеющимися данными, а только нужными. Условно говоря,
если у нас сеть магазинов, то необязательно отправлять в базу данных центрального офиса информацию по каждому пробитому чеку,
достаточно общей сводки. А еще можно к этому добавить подразделения, нуждающиеся в какой-то специфической информации (например,
сервисный центр), приложения для взаимодействия с постоянными партнерами и так далее — гибкость лишней не будет. Причем все
программы у нас независимы и, при правильном проектировании, сбой в одной из них не затронет все остальные.</p>

<p>Кроме того, таким образом можно связывать уже имеющиеся информационные системы, если, конечно, они работают с Ruby. Особо
интересен тут факт, что версии Ruby могут быть разными — требуется только совпадение версий формата маршалинга, который
на данный момент во всех активно используемых версиях — от 1.8.7 до 2.1 — один и тот же. Конечно, можно обойтись и другими
средствами — веб-сервисами, например, обменивающимися данными в формате JSON или XML, но это дополнительные расходы,
как машинной нагрузки, так и времени разработки, на которые, вероятно, стоит идти только если у нас уже имеются какие-то
элементы системы, работающие по данным протоколам. Хотя и в этом случае можно рассмотреть вариант ruby-обертки или расширения,
особенно если в долгосрочных планах всё равно стоит их переработка или замена — тут уже по обстоятельствам.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:gist">
      <p>Полные исходные тексты примеров размещены по адресу <a href="https://gist.github.com/shikhalev/6945234">https://gist.github.com/shikhalev/6945234</a>. <a href="#fnref:gist" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:safe">
      <p>Dave Thomas, with Chad Fowler and Andy Hunt, «Programming Ruby: The Pragmatic Programmers’ Guide»,
     бесплатная версия первого издания — <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/">http://www.ruby-doc.org/docs/ProgrammingRuby/</a> [en]. Глава «Locking Ruby in the Safe». <a href="#fnref:safe" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:openssh">
      <p>Официальный сайт OpenSSH — <a href="http://www.openssh.org/">http://www.openssh.org/</a>. <a href="#fnref:openssh" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:ssl">
      <p>Много полезной информации можно почерпнуть из документации к OpenSSL — <a href="http://www.openssl.org/">http://www.openssl.org/</a>, неплохое введение на русском языке
    находится по адресу <a href="http://xgu.ru/wiki/OpenSSL">http://xgu.ru/wiki/OpenSSL</a>. <a href="#fnref:ssl" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Иван Шихалев</name></author><category term="[&quot;tech&quot;, &quot;programming&quot;, &quot;ruby&quot;, &quot;pub&quot;, &quot;samag&quot;]" /><category term="сериализация" /><category term="сети" /><category term="dRuby" /><category term="RPC" /><summary type="html"><![CDATA[Введение в технологию dRuby. Прозрачный RPC для взаимодействия Ruby-программ.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://shikhalev.github.io/img/2015/03/31/druby/screen-druby-640x640-500-261-0-0.webp" /><media:content medium="image" url="https://shikhalev.github.io/img/2015/03/31/druby/screen-druby-640x640-500-261-0-0.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Декораторы в Ruby</title><link href="https://shikhalev.github.io/2015/03/decorator.html" rel="alternate" type="text/html" title="Декораторы в Ruby" /><published>2015-03-30T00:00:00+00:00</published><updated>2015-03-30T00:00:00+00:00</updated><id>https://shikhalev.github.io/2015/03/decorator</id><content type="html" xml:base="https://shikhalev.github.io/2015/03/decorator.html"><![CDATA[<p><a href="http://samag.ru/archive/article/2520">Оригинал этой статьи опубликован в журнале «Системный администратор» №9 (130) за сентябрь 2013</a>.</p>

<hr />

<figure class="__figure __implicit_figure __right" style="max-width:158px;padding: 5px;"><a href="http://samag.ru/archive/article/2520"><img src="/img/2015/03/30/decorator/130-158.webp" class="__image" /></a></figure>

<div class="note">
  <p>Как известно, в языке Python существует красивый механизм декораторов, расширяющих функционал объекта без изменения
интерфейса. Это довольно мощное средство, попользоваться им удобно и приятно. Но вот проблема: наш язык
программирования — Ruby!</p>

  <p>На самом деле никакой проблемы нет, и в Ruby достаточно возможностей, чтобы решать подобные задачи не менее эффективно,
чем в конкурирующих технологиях.</p>

  <p>… … …</p>

  <p>Универсальность всегда увеличивает сложность и накладные расходы. Так что мое мнение: жили мы без декораторов в Ruby
и еще поживем. Тем не менее сама методика декорирования кода, безусловно, заслуживает внимания и может с успехом применяться
в самых разных задачах.</p>
</div>

<!--more-->

<hr style="clear: both;" />

<div class="sticker right" style="max-width:300px;">
  <p><u>Декоратор в общем смысле</u> — шаблон проектирования, предусматривающий динамическое подключение дополнительной
функциональности к некоторому уже имеющемуся объекту без изменения его интерфейса. Старая функциональность оказывается
как бы обернута в новую.</p>

  <p><u>Декоратор в языке программирования Python</u> — специальная синтаксическая конструкция, «оборачивающая» заданную
функцию с использованием ранее определенной функции-обертки. Обо­ра­чи­ва­ю­щая функция принимает в качестве аргументов
заданную и, возможно, какие-то дополнительные параметры, которые в дальнейшем указываются при ис­пользовании декоратора,
и возвращает замещающую функцию.</p>

  <p>Простой пример:</p>

  <figure class="highlight">
    <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">wrapped</span>

<span class="vi">@log</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
  <span class="nb">print</span><span class="p">(</span><span class="s2">"Test"</span><span class="p">)</span>

<span class="nb">test</span><span class="p">()</span></code></pre>
  </figure>

</div>

<p>Идея этой статьи навеяна постом на Хабре о декораторах в языке Python<sup id="fnref:habr"><a href="#fn:habr" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>, а также некоторыми другими материалами в сети
на ту же тему. Авторы данных материалов явно гордятся такой возможностью языка, что прямо таки заставляет правоверного рубиста
выяснить, а как обстоят дела с аналогами в любимом языке. Конечно, надо понимать, что при всей близости по времени появления,
объектно-ориентированности и области применения, Python и Ruby все же разные языки, соответственно, аналоги получаются не один
к одному. Но можно говорить о схожих решениях схожих задач. Если мы откроем вышеупомянутый хабрапост, то увидим, в частности:</p>

<blockquote>
  <p>«Для того, чтобы понять, как работают декораторы, в первую очередь следует осознать, что в Python’е функции — это тоже объекты»</p>
</blockquote>

<p>И тут уже приходится остановиться: в Ruby, во-первых, нет функций, есть только методы, а во-вторых, методы объектами не являются.
Все плохо? Ничего подобного. Возможностей метапрограммирования в Ruby более чем достаточно для того, чтобы реализовать аналогичную
функциональность. Это и будет предметом настоящей статьи.</p>

<p>Пара слов о том, зачем это надо: способы применения могут быть самые разные — от ведения логов и замеров производительности
до проверки прав пользователя или каких-то еще сложных условий перед выполнением каждого действия. Причем, обрамлять своими
проверками мы можем любые методы, в том числе принадлежащие классам стандартной библиотеки языка, или библиотек, разрабатываемых
третьими лицами. Поскольку исходный код имеющихся библиотек не модифицируется, мы не создаем себе никаких препятствий к установке
обновлений и исправлений, что важно для проектов с длительным жизненным циклом.</p>

<h2 id="блоки-методы-и-объекты-proc">Блоки, методы и объекты Proc</h2>

<p class="note"><em>Здесь и далее я описываю сложные, но хорошо документированные, особенности языка применительно к основной теме статьи, кратко,
не всегда формально точно и, по возможности, просто. Для изучения языка лучше всего обратиться к более-менее официальным<sup id="fnref:ppg"><a href="#fn:ppg" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>
и неофициальным<sup id="fnref:wiki"><a href="#fn:wiki" class="footnote" rel="footnote" role="doc-noteref">3</a></sup> руководствам.</em></p>

<p>Итак, что мы имеем на уровне языка? Во-первых, это, конечно, <em>методы</em>. В принципе — те же функции, но определенные для класса
и исполняющиеся в контексте объекта. Замечу, что метод всегда определен для какого-то класса, даже если формально он задан
непосредственно объекту: так называемые синглтон-методы это методы так называемых синглтон-классов. Методы, определенные
в глобальном контексте принадлежат классу <code class="language-plaintext highlighter-rouge">Object</code>. С помощью метода <code class="language-plaintext highlighter-rouge">method</code> можно получить для данного метода объект класса
<code class="language-plaintext highlighter-rouge">Method</code> («Шишков, прости…»), который уже есть полноценный ruby-объект.</p>

<p>Во-вторых, это <em>блоки</em> — их можно рассматривать как анонимные функции, образующие замыкание с тем контекстом, в котором они
определены. При этом язык так устроен, что определяем блок мы всегда, передавая его в некий метод, где он доступен, помимо особых
средств языка, и как объект класса <code class="language-plaintext highlighter-rouge">Proc</code>.</p>

<p>Одним из таких методов, принимающих блоки, является метод класса <code class="language-plaintext highlighter-rouge">Module</code> <code class="language-plaintext highlighter-rouge">define_method</code>, который волшебным образом превращает
блок в метод. С другой стороны, объект класса <code class="language-plaintext highlighter-rouge">Proc</code>, а также любой объект, для которого определен метод <code class="language-plaintext highlighter-rouge">to_proc</code>, в том числе
и класса <code class="language-plaintext highlighter-rouge">Method</code>, может быть передан в качестве блока посредством префикса <code class="language-plaintext highlighter-rouge">&amp;</code>.</p>

<p>Демонстрация:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">show</span> <span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="nb">puts</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">alpha</span> <span class="n">x</span>
  <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">end</span>
<span class="n">a</span> <span class="o">=</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:alpha</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">a</span><span class="p">.</span><span class="nf">inspect</span>
<span class="nb">puts</span> <span class="n">a</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">b</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="n">b</span><span class="p">.</span><span class="nf">inspect</span>
<span class="no">Object</span><span class="p">.</span><span class="nf">send</span> <span class="ss">:define_method</span><span class="p">,</span> <span class="ss">:beta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span>
<span class="nb">puts</span> <span class="n">beta</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">show</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span>
<span class="n">show</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span>
<span class="n">show</span> <span class="mi">10</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
<span class="k">end</span></code></pre>
</figure>

<p>На выходе должны получить что-то вроде этого:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby deco2.rb
<span class="go">♯‹Method: Object♯alpha›
1
♯‹Proc:0x00000000af1298@deco1.rb:14›
2
11
12
13</span></code></pre>
</figure>

<p>Здесь мы из метода <code class="language-plaintext highlighter-rouge">alpha</code> получили объект, а метод <code class="language-plaintext highlighter-rouge">beta</code> наоборот, создали из объекта. «<code class="language-plaintext highlighter-rouge">Object.send :define_method</code>»
вместо «<code class="language-plaintext highlighter-rouge">Object.define_method</code>» пришлось использовать потому, что <code class="language-plaintext highlighter-rouge">define_method</code> — приватный.</p>

<p>Теперь, определившись, что у нас есть, можно перейти к рассмотрению того, что можно из этого сделать…</p>

<h2 id="шаг-первый--функция-обертка">Шаг первый — функция-обертка</h2>

<p>Очевидно, что там, где в Python функция, принимающая и возвращающая функцию, у нас будет метод, принимающий объект класса
<code class="language-plaintext highlighter-rouge">Proc</code>, а лучше — для универсальности — блок, и возвращающий объект класса <code class="language-plaintext highlighter-rouge">Proc</code>.</p>

<p>Давайте напишем обертку-логгер:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">wrap</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="nb">proc</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="o">|</span>
    <span class="k">begin</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span>
      <span class="vg">$stderr</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"OK: </span><span class="si">#{</span><span class="n">args</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span> <span class="o">+</span>
          <span class="s2">" =&gt; </span><span class="si">#{</span><span class="n">result</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
      <span class="n">result</span>
    <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
      <span class="vg">$stderr</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"ERROR! </span><span class="si">#{</span><span class="n">args</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2"> =&gt; </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
      <span class="k">raise</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>И протестируем ее:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="n">alpha</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">|</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span> <span class="p">}</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">wrap</span> <span class="o">&amp;</span><span class="n">alpha</span>

<span class="n">z1</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">call</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">z2</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">call</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span></code></pre>
</figure>

<p>Получаем (в предположении, что определение обертки и тестирующий код находятся в файле <code class="language-plaintext highlighter-rouge">deco2.rb</code>, как у меня<sup id="fnref:gist"><a href="#fn:gist" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>):</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby deco2.rb
<span class="go">OK: [4, 2] =› 2
ERROR! [4, 0] =› ♯‹ZeroDivisionError: divided by 0›
deco2.rb:16:in `/': divided by 0 (ZeroDivisionError)
        from deco2.rb:16:in `block in ‹main›'
        from deco2.rb:6:in `call'
        from deco2.rb:6:in `block in wrap'
        from deco2.rb:21:in `call'
        from deco2.rb:21:in `‹main›'</span></code></pre>
</figure>

<p>Здесь хорошо видно, что мы получили исключение, вывели информацию о нем и отправили его дальше по стеку вызовов.
Это сделано затем, чтобы и в плане исключений обертка вела себя так же, как исходная функция.</p>

<p>Чтобы в начале и конце у нас был метод, требуется добавить в общем-то немного:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">wrap_method</span> <span class="nb">name</span>
  <span class="no">Object</span><span class="p">.</span><span class="nf">send</span> <span class="ss">:define_method</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">wrap</span> <span class="o">&amp;</span><span class="p">(</span><span class="nb">method</span> <span class="nb">name</span><span class="p">))</span>
<span class="k">end</span></code></pre>
</figure>

<p>Получаем метод, создаем обертку и на ее основе переопределяем метод с тем же именем. Проверяем как-то так:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">alpha</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
  <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
<span class="k">end</span>

<span class="n">wrap_method</span> <span class="ss">:alpha</span>

<span class="n">alpha</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">alpha</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span></code></pre>
</figure>

<h2 id="шаг-второй--в-правильном-контексте">Шаг второй — в правильном контексте</h2>

<p>Примеры выше даны для глобального контекста, в котором, однако, на практике методы определяют редко. Нормальное
расположение методов — в контексте класса или модуля. Или попросту модуля, поскольку класс в данном случае есть
его разновидность (очень специфическая, но все же).</p>

<p>Поместим метод <code class="language-plaintext highlighter-rouge">wrap</code> в явном виде в класс <code class="language-plaintext highlighter-rouge">Object</code> (на самом деле, он и так там, просто сделаем определение более
ясным) и заставим его принимать не только блоки, но и непосредственно объекты класса <code class="language-plaintext highlighter-rouge">Method</code>, чтобы иметь доступ
к имени метода, а также класса <code class="language-plaintext highlighter-rouge">UnboundMethod</code>, чтобы оперировать методами, не привязанными к конкретному объекту.</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Object</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">wrap</span> <span class="n">meth</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">meth</span> <span class="o">||</span> <span class="n">block</span>
    <span class="nb">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">meth</span> <span class="o">&amp;&amp;</span> <span class="n">meth</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span> <span class="o">||</span> <span class="s1">''</span>
    <span class="nb">proc</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="o">|</span>
      <span class="k">if</span> <span class="no">UnboundMethod</span> <span class="o">===</span> <span class="n">func</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">.</span><span class="nf">bind</span> <span class="nb">self</span>
      <span class="k">end</span>
      <span class="k">begin</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">.</span><span class="nf">call</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span>
        <span class="vg">$stderr</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"OK: </span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span> <span class="o">+</span>
            <span class="s2">" </span><span class="si">#{</span><span class="n">args</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2"> =&gt; </span><span class="si">#{</span><span class="n">result</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
        <span class="n">result</span>
      <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
        <span class="vg">$stderr</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"ERROR! </span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span> <span class="o">+</span>
            <span class="s2">" </span><span class="si">#{</span><span class="n">args</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2"> =&gt; </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
        <span class="k">raise</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">wrap_singleton_method</span> <span class="o">*</span><span class="n">names</span>
    <span class="n">names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
      <span class="n">define_singleton_method</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wrap</span><span class="p">(</span><span class="nb">method</span> <span class="nb">name</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="k">class</span> <span class="nc">Module</span>

  <span class="k">def</span> <span class="nf">wrap_method</span> <span class="o">*</span><span class="n">names</span>
    <span class="n">names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
      <span class="n">define_method</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wrap</span><span class="p">(</span><span class="nb">instance_method</span> <span class="nb">name</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre>
</figure>

<p>И попробуем:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Fixnum</span>

  <span class="n">wrap_method</span> <span class="p">:</span><span class="o">+</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span>

<span class="k">end</span>

<span class="n">z0</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">z1</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">mul</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="k">end</span>

<span class="n">wrap_singleton_method</span> <span class="ss">:mul</span>

<span class="n">z2</span> <span class="o">=</span> <span class="n">mul</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span></code></pre>
</figure>

<p>Получим:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby deco4.rb
<span class="go">OK: 4.+ [2] =› 6
OK: 4.- [2] =› 2
OK: main.mul [4, 2] =› 8</span></code></pre>
</figure>

<p>Нетрудно заметить, что использование <code class="language-plaintext highlighter-rouge">wrap_method</code> выглядит весьма похоже на стандартные модификаторы <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">protected</code>
и <code class="language-plaintext highlighter-rouge">public</code>. Давайте еще усилим эту похожесть (а заодно и похожесть на python-декораторы) — при вызове без параметров, метод
будет действовать на все последующие определения. Модифицируем <code class="language-plaintext highlighter-rouge">wrap_method</code>:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">wrap_method</span> <span class="o">*</span><span class="n">names</span>
  <span class="k">if</span> <span class="n">names</span><span class="p">.</span><span class="nf">length</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="vi">@ignore_wrap</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="n">names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
      <span class="n">define_method</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wrap</span><span class="p">(</span><span class="nb">instance_method</span> <span class="nb">name</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="vi">@ignore_wrap</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">else</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="nb">method</span> <span class="ss">:method_added</span>
    <span class="n">define_singleton_method</span> <span class="ss">:method_added</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
      <span class="n">wrap_method</span> <span class="nb">name</span> <span class="k">unless</span> <span class="vi">@ignore_wrap</span>
      <span class="n">ma</span><span class="p">.</span><span class="nf">call</span> <span class="nb">name</span> <span class="k">if</span> <span class="n">ma</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>

<p>Метод класса <code class="language-plaintext highlighter-rouge">Module</code> <code class="language-plaintext highlighter-rouge">method_added</code> вызывается при любом определении метода. Чтобы не уйти в бесконечный цикл, нам приходится
дополнительно ввести флаг, говорящий о том, что текущее определение — это наша обертка, которую заново оборачивать не нужно.</p>

<p>Кстати, здесь мы вместо того, чтобы перекрыть метод <code class="language-plaintext highlighter-rouge">method_added</code> создаем (опять же) над ним обертку. Сделано это затем, чтобы
нам не помешали его возможные переобъявления. Проверим на следующем коде:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Alpha</span>

  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>

    <span class="k">def</span> <span class="nf">method_added</span> <span class="nb">name</span>
      <span class="nb">puts</span> <span class="s2">"method_added: </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>

  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">alpha</span>
    <span class="nb">p</span> <span class="ss">:alpha</span>
  <span class="k">end</span>

  <span class="n">wrap_method</span>

  <span class="k">def</span> <span class="nf">beta</span>
    <span class="nb">p</span> <span class="ss">:beta</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">gamma</span>
    <span class="nb">p</span> <span class="ss">:gamma</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Alpha</span><span class="p">.</span><span class="nf">new</span>

<span class="n">a</span><span class="p">.</span><span class="nf">alpha</span>
<span class="n">a</span><span class="p">.</span><span class="nf">beta</span>
<span class="n">a</span><span class="p">.</span><span class="nf">gamma</span></code></pre>
</figure>

<p>Должно получиться на выходе:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby deco5.rb
<span class="go">method_added: alpha
method_added: beta
method_added: beta
method_added: gamma
method_added: gamma
:alpha
:beta
OK: ♯‹Alpha:0x00000001e7c510›.beta [] =› :beta
:gamma
OK: ♯‹Alpha:0x00000001e7c510›.gamma [] =› :gamma</span></code></pre>
</figure>

<p>Аналогично можно модифицировать и <code class="language-plaintext highlighter-rouge">wrap_singleton_method</code>, если очень хочется.</p>

<h2 id="шаг-третий--фабрика-генераторов">Шаг третий — фабрика генераторов</h2>

<p>Ну и наконец, давайте решим задачу в более-менее общем виде. Пусть у нас будет способ генерировать различные «декораторы»,
задав имя и блок, возвращающий <code class="language-plaintext highlighter-rouge">proc</code>-обертку. Блок будет принимать <code class="language-plaintext highlighter-rouge">UnboundMethod</code> и произвольные именованные параметры.
Только именованные, поскольку неименованный список мы будем вместе с ними передавать при вызове декоратора — это имена
декорируемых методов, как и в примерах выше. В python-декораторах так делать не принято, зато в Ruby подобное сплошь и рядом.</p>

<p class="note"><em>Для упрощения и сокращения кода далее я использую синтаксическую конструкцию для задания именованных параметров,
которая появилась только в Ruby версии 2.0 (предыдущие примеры полностью работоспособны и в 1.9). Сделать тоже самое
в предыдущих версиях вполне реально, но несколько длиннее.</em></p>

<p>Вот такое короткое определение:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Module</span>

  <span class="k">def</span> <span class="nf">decorator</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wrapper</span>
    <span class="n">define_singleton_method</span> <span class="nb">name</span> <span class="k">do</span> <span class="o">|*</span><span class="n">names</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">names</span><span class="p">.</span><span class="nf">length</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="vi">@ignore_wrap</span> <span class="o">=</span> <span class="kp">true</span>
        <span class="n">names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">nm</span><span class="o">|</span>
          <span class="n">define_method</span> <span class="n">nm</span><span class="p">,</span>
              <span class="o">&amp;</span><span class="n">wrapper</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">instance_method</span><span class="p">(</span><span class="n">nm</span><span class="p">),</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="vi">@ignore_wrap</span> <span class="o">=</span> <span class="kp">false</span>
      <span class="k">else</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="nb">method</span> <span class="ss">:method_added</span>
        <span class="n">define_singleton_method</span> <span class="ss">:method_added</span> <span class="k">do</span> <span class="o">|</span><span class="n">nm</span><span class="o">|</span>
          <span class="nb">send</span> <span class="nb">name</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span> <span class="k">unless</span> <span class="vi">@ignore_wrap</span>
          <span class="n">ma</span><span class="p">.</span><span class="nf">call</span> <span class="n">nm</span> <span class="k">if</span> <span class="n">ma</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre>
</figure>

<p>Прогоним тестовый пример:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="vg">$:</span> <span class="o">&lt;&lt;</span> <span class="s1">'.'</span>

<span class="nb">require</span> <span class="s1">'deco'</span>

<span class="k">class</span> <span class="nc">Alpha</span>

  <span class="n">decorator</span> <span class="ss">:echo</span> <span class="k">do</span> <span class="o">|</span><span class="n">unbound</span><span class="p">,</span> <span class="ss">prefix: </span><span class="s1">'echo: '</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="o">|</span>
    <span class="nb">proc</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="o">|</span>
      <span class="nb">puts</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">'name = '</span> <span class="o">+</span>
          <span class="n">unbound</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">inspect</span> <span class="k">if</span> <span class="n">opts</span><span class="p">[</span><span class="ss">:name</span><span class="p">]</span>
      <span class="nb">puts</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">'args = '</span> <span class="o">+</span> <span class="n">args</span><span class="p">.</span><span class="nf">inspect</span> <span class="k">if</span> <span class="n">opts</span><span class="p">[</span><span class="ss">:args</span><span class="p">]</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">unbound</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="nb">self</span><span class="p">).</span><span class="nf">call</span> <span class="o">*</span><span class="n">args</span>
      <span class="nb">puts</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">'result = '</span> <span class="o">+</span>
          <span class="n">result</span><span class="p">.</span><span class="nf">inspect</span> <span class="k">if</span> <span class="n">opts</span><span class="p">[</span><span class="ss">:result</span><span class="p">]</span>
      <span class="n">result</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">alpha</span>
    <span class="ss">:alpha</span>
  <span class="k">end</span>

  <span class="n">echo</span> <span class="ss">:alpha</span><span class="p">,</span> <span class="ss">prefix: </span><span class="s1">''</span><span class="p">,</span> <span class="ss">result: </span><span class="kp">true</span>

<span class="k">end</span>

<span class="k">class</span> <span class="nc">Beta</span> <span class="o">&lt;</span> <span class="no">Alpha</span>

  <span class="k">def</span> <span class="nf">beta</span> <span class="n">x</span>
    <span class="s2">"BETA: "</span> <span class="o">+</span> <span class="n">x</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="k">end</span>

  <span class="n">echo</span> <span class="ss">:beta</span><span class="p">,</span> <span class="ss">args: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">result: </span><span class="kp">true</span>

  <span class="n">echo</span> <span class="ss">args: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">name: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">result: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">prefix: </span><span class="s1">'[*] '</span>

  <span class="k">def</span> <span class="nf">gamma</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
    <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">b</span> <span class="o">=</span> <span class="no">Beta</span><span class="p">.</span><span class="nf">new</span>

<span class="n">b</span><span class="p">.</span><span class="nf">alpha</span>
<span class="n">b</span><span class="p">.</span><span class="nf">beta</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">.</span><span class="nf">gamma</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span></code></pre>
</figure>

<p>И получим:</p>

<figure class="highlight">
  <pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>ruby demo.rb
<span class="go">result = :alpha
echo: args = [1]
echo: result = "BETA: 1"
[*] name = :gamma
[*] args = [1, 2, 3]
[*] result = 6</span></code></pre>
</figure>

<h2 id="идем-дальше">Идем дальше?</h2>

<p>Как видим, все работает. Кроме того, определения декораторов прекрасно наследуются. Для дальнейшего развития можно
поработать над тем, чтобы они еще и «включались» при добавлении mixin-модуля, предусмотреть отмену и/или переключение
и так далее. Но… так уж ли все это нужно? Тем более, что есть не столь универсальный, зато очень простой и достаточный
в большинстве случаев способ сделать обертку:</p>

<figure class="highlight">
  <pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Fixnum</span>

  <span class="k">alias</span> <span class="ss">:mul</span> <span class="p">:</span><span class="o">*</span>

  <span class="k">def</span> <span class="nf">*</span> <span class="n">x</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mul</span> <span class="n">x</span>
    <span class="vg">$stderr</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2"> * </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2"> = </span><span class="si">#{</span><span class="n">result</span><span class="si">}</span><span class="s2">"</span>
    <span class="n">result</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre>
</figure>

<p>Универсальность всегда увеличивает сложность и накладные расходы. Так что лично мое мнение: жили мы без декораторов в Ru­by,
и еще поживем. Тем не менее сама методика декорирования кода, безусловно, заслуживает внимания и может с успехом применяться
в самых разных задачах.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:habr">
      <p>«Понимаем декораторы в Python’e, шаг за шагом», <a href="http://habrahabr.ru/post/141411/">http://habrahabr.ru/post/141411/</a> и <a href="http://habrahabr.ru/post/141501/">141501/</a>,
     перевод с английского — Владислав Степанов; оригинал: “What are Python decorators?”, Renaud Gaudin, <a href="http://yeleman.com/what-are-python-decorators/">http://yeleman.com/what-are-python-decorators/</a>. <a href="#fnref:habr" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:ppg">
      <p>Dave Thomas, with Chad Fowler and Andy Hunt, «Programming Ruby: The Pragmatic Programmers’ Guide», бесплатная версия первого
    издания — <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/">http://www.ruby-doc.org/docs/ProgrammingRuby/</a> [en]. <a href="#fnref:ppg" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:wiki">
      <p>Викиучебник по Ruby, <a href="http://ru.wikibooks.org/wiki/Ruby">http://ru.wikibooks.org/wiki/Ruby</a>. <a href="#fnref:wiki" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:gist">
      <p>Полные тексты всех примеров можно взять на GitHub Gist: <a href="https://gist.github.com/shikhalev/6259566">https://gist.github.com/shikhalev/6259566</a>. <a href="#fnref:gist" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Иван Шихалев</name></author><category term="[&quot;tech&quot;, &quot;programming&quot;, &quot;ruby&quot;, &quot;pub&quot;, &quot;samag&quot;]" /><category term="метапрограммирование" /><summary type="html"><![CDATA[Реализация паттерна «декоратор» на языке Ruby]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://shikhalev.github.io/img/2015/03/30/decorator/screen-decos-640x640-500-261-0-0.webp" /><media:content medium="image" url="https://shikhalev.github.io/img/2015/03/30/decorator/screen-decos-640x640-500-261-0-0.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>