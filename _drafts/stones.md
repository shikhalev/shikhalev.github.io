---
title: Отчет о рефакторинге
description: Как я рефакторил сайт, с чем столкнулся и о чем узнал
category:
  - tech
  - web
  - programming
  - about
image: /assets/img/2021-07/report/jekyll-screen.png
tags:
  - shikhalev.org
  - сайты
  - блоги
  - верстка
  - Jekyll
  - статическая генерация
  - HTML
  - CSS
  - JavaScript
  - грабли
  - markdown
  - SASS
  - SCSS
  - kramdown
  - Liquid
---
{% include image.liquid place="right" width=320 src="/assets/img/2021-07/report/jekyll-screen.png"
   caption="Скриншот с [официального сайта Jekyll](https://jekyllrb.com/)" %}

Итак, я таки отрефакторил и обновил данный сайт. Почему нельзя было сразу делать правильно? Ну, в основном потому,
что я впервые имел дело с Jekyll, изрядно подзабыл (а что-то и не знал) базовые приемы верстки... И так далее,
и тому подобное.

Вторая (в моем случае) причина — это то, что, как это часто бывает, представление о желаемом результате уточнялось
и формировалось в процессе достижения результата просто работающего. Соответственно, решение «исторически сложилось»,
если вы понимаете, о чем я. Любой проект ставит разработчика перед выбором: или бесконечное (и потому бесплодное)
делание «как надо», или движение к идеалу через неидеальные, зато рабочие, варианты, которые, впрочем, без регулярного
рефакторинга быстро становятся неулучшаемым и иногда не совсем рабочим болотом.

Но на самом деле этот пост не только, и не столько о рефакторинге как таковом, сколько о технической стороне этого
сайта в целом. Благо, сразу после выкатки первого варианта я так технический пост и не написал, желая сначала получше
разобраться. Вот, сейчас и пишу о том, с чем разобрался, и о процессе этого разбирательства.

<!--more-->

## Выбор технологий

### Бэкенд

Сайт сделан на статическом генераторе **[Jekyll][jekyll]{:.img-icon-jekyll}** и размещен на **[GitHub Pages][pages]{:.img-icon-github}**,
чтобы не платить за хостинг. Комментарии — **[Staticman][staticman]{:.img-icon-staticman}**, размещенный на **[Heroku][heroku]{:.img-icon-heroku}**
также бесплатно. Собственно, бесплатность была для меня необходимым критерием при выборе технологии, поскольку блогом я не зарабатываю.

{:.note.italic}
За все время существования [технобложика][bs], гуглореклама, крутящаяся там, не докрутилась до минимально выводимой суммы, даже
не приблизилась. Поэтому сейчас при рефакторинге я ее и убрал совсем (хотя в скрытых элементах верстки и оставил — место под нее,
но не ее саму — и если вдруг посещаемость взлетит на несколько порядков, могу вернуть). [Блок-по­про­шай­ка](#donate) сработал пока
1 (один) раз за все время. Что приятно, но тоже не позволяет говорить о профите или окупаемости.

Почему не [ЖЖ][livejournal], [Blogger][blogger], [Wordpress][wordpress] и так далее?

: Несколько факторов:

  *Возможности контроля верстки* — я хочу, чтоб мои посты выглядели так, как я хочу. В ЖЖ (и [DW][dreamwidth]) эти возможности
  вообще крайне скудны. В Blogger и Wordpress они достаточно богаты, но требуют серьезных усилий, чтобы навесить свое оформление
  поверх сложных механизмов движка.

  Более того, мне нужно одновременно иметь контроль над версткой и возможность о ней не задумываться при написании текстов,
  то есть разметку типа [Markdown][markdown] и автоматическую систему раскраски исходного кода. И еще что-нибудь вроде макросов
  для тех случаев, когда маркдауна не достаточно.

  *Возможность легкого и быстрого «перезда»* на случай, если мои тексты вступят в конфликт с политикой хостера, или его самого
  заблокируют. Увы, в последнее время угроза бана на любом сервисе вполне реальна, для этого не требуется нарушать законы,
  достаточно стука со стороны «прогрессивной общественности». Ну, а российские блокировки и вовсе лупят по площадям, как в копеечку...

  И хотя упомянутые сервисы и позволяют делать какие-то архивы и бэкапы, развернуть их где-то еще не получится. Исключение — Wordpress,
  который можно поднять и на своем сервере, но учитывая его сложность и системные требования, быстрым и легким такой переезд
  точно не назовешь.

  Еще важное пожелание — *контроль версий*. **[Git][git]{:.img-icon-git}**, развертывание сайта из репозитория, человекочитаемая история
  изменений, и так далее, и тому подобное.

  В общем, *вендор-лок* и сложность/невозможность *существенной* кастомизации делают готовые блог-платформы для меня не лучшим выбором.

Почему не свой сервер с самописным бэкендом на рельсах или другом фреймворке?

: Тут просто — *цена*. Причем, кроме затрат на хостинг нуж­но еще учитывать время на разработку и администрирование. Хотя, конечно,
  сейчас все это не так уж и дорого и, как вариант «в случае чего», я вполне рассматриваю переезд на ненавороченный VPS/VDS, причем
  именно в текущем виде, со статической генерацией, мне достаточно будет са­мо­го-пре­са­мо­го дешевого.

При всем при этом мне *не* нужна логика на бэкенде, динамически формируемые страницы, вот это всё. Даже комментарии, в об­щем-то,
вторичны. Таким образом, все пути ведут к *генераторам статических страниц*.

Почему именно Jekyll?

: Ключевое его преимущество — интеграция с GitHub Pages. То есть схема работы не «сгенерировал страницы из рабочей копии репозитория
  и отправил на сервер», а «написал, закоммитил, запушил» — публикация происходит автоматически при фиксации изменений, исходники
  в репозитории и сайт всегда синхронизированы, то есть не возникает ситуация, когда в репозиторий закоммитил, а опубликовать забыл,
  или, что еще хуже — опубликовал, не закоммитил, и в истории изменений реально работающая версия не попала. Аналогичным образом можно
  организовать публикацию и через **[GitLab][gitlab]{:.img-icon-gitlab}** (там, впрочем, вариантов побольше, но первичный расчет все же
  на GitHub, поскольку я им давно активно пользуюсь). На собственном хостинге эти фазы будут разделены, но во-пер­вых, см. выше про первичный
  расчет, а во-вто­рых, можно и там такое организовать через [хуки Git][git-hooks].

  Второй важный аспект — это то, что Jekyll является [свободным ПО][fs-wiki], [его код открыт][jekyll-code] и опубликован
  под [ли­цен­зи­ей MIT][jekyll-mit]. Что, впрочем, характерно и для многих его аналогов с точностью до конкретной лицензии...

  Менее существенно, но субъективно тоже приятно, что Jekyll написан на **[Ruby][ruby-lang]{:.img-icon-ruby}** — одном из моих любимых языков.
  Что означает реальную, а не гипотетическую возможность воспользоваться преимуществами open source с моей стороны. Реализую ли я ее —
  это отдельный  вопрос, однако мое знакомство с пакетной инфраструктурой Ruby — плагины Jekyll распространяются именно как гемы — явно мне
  помогло в его установке и настройке.

  Что же касается недостатков и подводных камней, далее будет еще много подробностей...

Почему именно Staticman?

: Для начала отмечу, что требования к системе комментариев у меня самые минимальные. И не могу сказать, чтобы я уделил этому вопросу
  много времени. Собственно, *ключевым* преимуществом Staticman стало простое развертывание на бесплатном аккаунте Heroku вкупе
  с возможностью также быстро и просто «в случае чего» развернуть его и на своем сервере (в наличии docker-образ).

  Кроме того:

  * Комментарии хранятся в том же репозитории, что и сайт. Можно и в другом, факт в том, что это будет а) git-ре­по­зи­то­рий, б) под моим управлением.

  * Прикручивается защита от спама. Есть два варианта: re­CAPT­CHA и A­kis­met, и со вторым я пока не разбирался, надеюсь, руки еще дойдут.
    О недостатках и проблемах рекапчи мне известно.

  * Визуальное отображение не просто кастомизируется, а вообще полностью находится в зоне ответственности владельца сайта.

  * [Исходники открыты][staticman-code], под лицензией MIT.

  Из недостатков стоит отметить:

  * Привязка к GitHub/GitLab. Это касается, конечно, не хостинга (Pages), а репозитория — Staticman для добавления комментариев использует
    API этих сервисов, а не пуши Git. Если и там, и там забанят, придется искать другой сервис комментариев. Впрочем, для своего хостинга
    их полно, да и собственный пишется на коленке легко и просто. А уже имеющиеся комментарии никуда не денутся — они в репозитории.

  * Нет авторизации. Кто угодно может писать под каким угодно именем.

  * Уведомления сделаны через Mailgun, который бесплатных тарифных планов не имеет (есть триальный, но это ж временно). Я не стал подключать.
    Вместо этого я в новой версии сайта добавил отображение последних (глобально) трех комментариев в [отдельной панели](#sidebar)
    на всех[^last-comments] страницах.

  В целом, вопрос идеальной системы комментариев остается открытым... Но все более-менее интересные варианты, с авторизацией через
  соцсети и т.д. — платные. Опять же, нельзя сказать, чтоб они были дороги, но сайт-то полностью непрофитный. В случае же переезда
  на платный хостинг, имеет смысл вернуться к этому вопросу именно в плане свободного софта, неподходящего для бесплатных хостингов,
  но подходящего для VPS/VDS.

### Фронтенд

Тут все просто: никаких фреймворков, никаких динамически формирующихся страниц. Зато и никакой заботы об устаревших браузерах (учитывая
отсутствие динамики, можно быть увереным, что информация будет доступна и на старинных браузерах, а вот верстка может и поехать, если
поддержка CSS недостаточна). При этом важно адекватное отображение на мобильных — как само по себе, так и как фактор поисковой оптимизации.

Статическая генерация приводит к тому, что любой клиент получает одни и те же данные, таким образом потенциально имеется три подхода:

* Верстать по старинным стандартам, что му́ка само по себе и, кроме того, получается крайне несемантично, то есть недружественно к современным
  поисковикам.

* Использовать фронтенд-фреймворки и переложить верстку на JavaScript, густо обмазавшись слоями совместимости. Ма­ло­ос­мыс­лен­но по трудозатратам
  и непредсказуемо по реакции поисковиков (они, конечно, сейчас умеют выполнять скрипты, но неизвестно, где их переклинит).

* Использовать простую современную семантическую верстку и позволить старым браузерам спокойно деградировать. В результате 1–2% посетителей
  получат не совсем то визуальное представление, что задумывалось, но спокойно смогут прочитать тексты и посмотреть картинки. А большинство
  увидит именно то, что и нужно, сразу адекватное их устройству, без скачивания (и исполнения) тонн ненужных скриптов совместимости.

Мы пойдем третьим путем и будем использовать: **[HTML5][html5]{:.img-icon-html5}** ради семантических тегов, **[CSS3][css3]{:.img-icon-css3}**
ради удобной верстки посредством `flex` и `grid`, а так­же **[JavaScript][js]{:.img-icon-javascript}** по ми­ни­муму[^js].

#### Внешние ресурсы

Из таковых у меня подгружаются шрифты с **[Google Fonts][google-fonts]{:.img-icon-gf}** — это
[свободно распространяемые шрифты **Paratype**{:.img-icon-paratype}][paratype] —
семейство PT Sans и PT Mo­no. На то есть две причины: во-пер­вых, на разных устройствах под разными операционными системами имеющиеся шрифты сильно разные,
а во-вто­рых зачастую ужасные и не согласованные между собой. Мне же хочется, чтобы, скажем, примеры кода (моноширинным шрифтом) не выбивались по общему виду —
метрикам, насыщенности и т.д. из основного текста. Аналогично согласованность желательна и для шрифтов заголовков с одной стороны, и сносок —
с другой.

Еще что касается шрифтов: также как веб-шрифт я подгружаю **[Font Awesome Free][fontawesome]{:.img-icon-fa}** — уже не снаружи, а копию на сайте.
Этим шрифтом сделаны монохромные иконки в оформлении сайта. Цветные в основном тексте — это уже картинки (по возможности [SVG][svg]), набранные
из разных источников[^devicon].

Кроме того, из внешних источников подгружаются следующие, условно говоря, модули:

* Счетчики — **[Goog­le Ana­ly­tics][analytics]{:.img-icon-analytics}** и **[Ян<span>­декс.​Мет­ри­ка</span>][metrica]{:.img-icon-metrica}**.

* Поиск по сайту от **[Goog­le][gce]{:.img-icon-gce}**.

* Форма-попрошайка от **[Yoo­mo­ney][yoomoney]{:.img-icon-yoomoney}**[^yoomoney].

Они, конечно, тянут за собой много всякого, но все-таки полезные.

## Разработка

Совсем пошагово описывать процесс я не буду. Дело это достаточно скучное, пройдусь по тем моментам, которые чем-то интересны,
или вызвали у меня затруднения.

### Jekyll

*Во-первых*, я при этом рефакторинге отказался от готовой темы. Изначально я использовал дефолтную для Jekyll тему minima, обвешивая ее
уже ка­ки­ми-то своими дополнениями. Это, в принципе, правильный путь — взять готовое, причем максимально простое, и дорабатывать,
но итоговая верстка достигалась грязными хаками и для адаптации под мобильные годилась мало (хотя сама тема вполне адаптирована).

Могу заметить, что никаких проблем с неиспользованием темы не обнаружилось. Собственно, движку без разницы, что обрабатывать.

*Во-вторых*, язык шаблонов **[Liquid][liquid]{:.img-icon-liquid}** — это что-то с чем-то. И мне, честно говоря, не понятно,
почему в Jekyll используется именно он, а не, например, [ERB][erb], идущий в комплекте с Ruby, на котором сам Jekyll написан... Возможно,
дело в том, что ERB *слишком* богат — по сути это полноценный Ruby, встраиваемый в шаблоны. А у Ruby с точки зрения встраивания
куда-либо есть один недостаток: невозможность сделать полностью изолированную песочницу. Хотя, на мой взгляд, имеющихся уровней
изоляции должно быть достаточно... Так вот, Liquid — система очень ограниченная.

В языке есть, в принципе, объекты или структуры, но создать их нельзя. Есть массивы, но чтобы создать массив, нужно пропустить
пустую строку, через фильтр `split`. Вообще всё делается через фильтры и выглядит это несколько странно. Точнее, в выражении
подстановки `{% raw %}{{ ... }}{% endraw %}` это выглядит хорошо, а вот если мы хотим присвоить значение переменной —
несколько избыточно, особенно в инструкции `{% raw %}{% assign ... %}{% endraw %}`.

Например, мы можем сделать так:

{% highlight liquid %}
{% raw %}<span class="{{ include.class }}">{{ include.title }}</span>{% endraw %}
{% endhighlight %}

Но если мы захотим передать такую составную строку как параметр в какой-то другой `{% raw %}{% include ... %}{% endraw %}`,
то вынуждены сначала присвоить ее переменной. И выглядеть это будет так:

{% highlight liquid %}
{% raw %}{% assign var = '<span class="' | append: include.class
                                | append: '">'
                                | append: include.title
                                | append: '</span>' %}{% endraw %}
{% endhighlight %}

Впрочем, не все так страшно — можно сделать так:

{% highlight liquid %}
{% raw %}{% capture var %}
<span class="{{ include.class }}">{{ include.title }}</span>
{% endcapture %}{% endraw %}
{% endhighlight %}

Но выглядит довольно непривычно.

Еще один момент — и это уже хорошо прикрытые грабли — то, что нет областей видимости и, соответственно, локальных переменных.
Единственный способ организовать нечто подобное — это те самые параметры `{% raw %}{% include ... %}{% endraw %}`, с ними
можно даже использовать рекурсию, других-то подпрограмм у нас нет. Тот факт, что при общей глобальности всех переменных,
параметры `include` не перезатирают друг друга при вложенных вызовах, оказался для меня приятным сюрпризом и большим удобством.

*В-третьих*, непонятки случаются и с объектами, предоставляемыми Jekyll. Например, объект `page` почему-то не предоставляет
свойство `name`, хотя оно [есть в документации][page-vars] (а еще лучше было бы `basename`), поэтому для страниц рубрик, то есть «категорий»
в терминологии Jekyll, приходится задавать вручную свойство `category_id`, хотя поначалу хотелось обойтись просто именованием
файлов.

*И, last but not least*, принцип Jekyll: один входной файл дает один выходной, сгенерировать несколько представлений для одной
страницы мы не можем. Есть, правда, объект `paginator`, но он работает только со всеми постами сразу, без категорий, или какой-то
еще фильтрации. Отсюда и такое мое решение, когда последние посты показываются, как принято в блогах, до ката, а дальше одна
страница с хронологией и только заголовками.

Вообще, конечно, *Jekyll отлично расширяется*, даже в части тегов Liquid, посредством плагинов, написанных на Ruby. И всё бы было
хорошо, если б не ограничения GitHub Pages — там допустимы только плагины из заранее определенного списка (и еще версия Jekyll
не самая распоследняя[^pages-vers]). Приходится довольствоваться малым. Или, как вариант, переходить на ло­каль­ную генерацию, отправляя
на Pa­ges только финальный результат.

#### Markdown

Нетрудно догадаться, что маркдаун у меня активно перемежается с разной более сложной версткой. И в первую очередь, это картинки,
обтекаемые текстом. На этой итерации я вынес их формирование в отдельный `include` и обернул в тег `<figure>` для семантичности.
При этом столкнулся с таким моментом: маркдаун упорно пытается обернуть теги `<img>` внутрь тегов `<p>`, да еще и лажает
с последовательностью закрывающих тегов (получается что-то типа `<figure><p>...</figure></p>`) и вся верстка рушится. Вообще,
по умолчанию такого бы не происходило, но у меня вручную в `_config.yml` выставлен параметр `kram­down.​parse_​block_​html` в `true`,
поскольку как правило парсинг внутри блочных тегов мне нужен. Однако, его можно запретить и локально, указав в самом теге
«атрибут» `markdown="0"`. При этом, как выяснилось, внутри во вложенных тегах, это поведение можно и скорректировать, так что
в `<figcaption>` я выставил `markdown="span"` (то есть обрабатывать только inline-разметку, не добавляя никаких `<p>`) и доволен,
как слон.

#### Оглавление

Очень полезный модуль **[allejo/jekyll-toc][jekyll-toc]{:.fa-icon-github}**, я даже в футере на него решил ссылку сделать. Также
рекомендую обратить внимание на его параметры, в частности `h_max` и `skip_no_ids`. Последний позволяет игнорировать заголовки
без атрибута `id` (или с пустым), чего можно добиться в mark­down указав `{: id=""}` непосредственно перед строкой заголовка.

<!-- 1. p внутри figure (решение — markdown="0"!!!) + figcaption с markdown="span" (+)

2. неочевидный приоритет (специфичность) селекторов

3. не забываем про viewport

4. убрал рекламу (+)

5. про печать comment-actions

6. Длинные урлы в сносках :(

7. Ограничение грида — нельзя дополнительную вложенность. Непонятно как сделать общие рамки с гапами.

8. max-width: 100% для main и box-sizing

9. неинтерполяция в assign и параметрах include (+)

1. Печать пре (переносы)

1. display: block для ифрейма + разрешения для ютуба

1. отсутствие name у элементов коллекций (+)

1. verse (white-space)

2. topper

3. wotermark и невозможность нумерации

1. Довольно трешовое неотрываение иконки, а также бэкграунд вместо контента и прочий геморрой

1. Иконки darktable и Luminance HDR не читаются браузерами (svg)

1. small категории -->

[^last-comments]: На самом деле — не на всех... В разделе «{% include link.liquid stream='text' %}» я этот блок отключил как отвлекающий. Но это такой специальный раздел.

[^js]: Сейчас у меня JS используется в двух местах: это обслуживание комментариев (там без него не получится, или получится крайне неадекватно,
       организовать ответы друг другу, и плюс попытка подтягивать обновленные комментарии в фоне) и кнопка «<span class="fas dark">&#xf35b;</span>»,
       то есть «Вернуться в начало страницы».

[^devicon]: Впрочем, один из источников стоит особой благодарности — <https://devicon.dev/>.

[^yoomoney]:  Бывшие Ян­декс.День­ги.

[^pages-vers]: Очень желательно эту самую версию зафиксировать и для локальной разработки через `Gemfile`, и/или добавить там зависимость от гема
               `github-pages`, который зафиксирует и версию Jekyll, и версии используемых плагинов. Иначе может получиться так, что прекрасно
               работающий локально сайт свалится на деплое.

[jekyll]: https://jekyllrb.com/ "Официальный сайт Jekyll"
[pages]: https://pages.github.com/ "GitHub Pages"
[staticman]: https://staticman.net/ "Официальный сайт Staticman"
[heroku]: https://www.heroku.com/ "Heroku"
[bs]: https://bs.shikhalev.org/ "Мой старый технобложик"
[livejournal]: https://www.livejournal.com/ "Живой Журнал — LiveJournal"
[blogger]: https://www.blogger.com/ "Блог-платформа от Google"
[wordpress]: https://www.wordpress.com/ "WordPress"
[dreamwidth]: https://www.dreamwidth.org/ "DreamWidth — форк LiveJournal"
[markdown]: https://ru.wikipedia.org/wiki/Markdown "Markdown — облегчённый язык разметки"
[git-hooks]: https://git-scm.com/book/ru/v2/Настройка-Git-Хуки-в-Git "Настройка Git - Хуки в Git"
[fs-wiki]: https://ru.wikipedia.org/wiki/Свободное_программное_обеспечение "Свободное программное обеспечение"
[jekyll-code]: https://github.com/jekyll/jekyll "Исходники Jekyll на GitHub"
[jekyll-mit]: https://github.com/jekyll/jekyll/blob/master/LICENSE "Лицензия Jekyll"
[ruby-lang]: https://www.ruby-lang.org/ru/ "Язык программирования Ruby"
[staticman-code]: https://github.com/eduardoboucas/staticman "Исходники Staticman на GitHub"
[gitlab]: https://gitlab.com/ "GitLab"
[git]: https://git-scm.com/ "Git — распределенная система контроля версий"
[html5]: https://ru.wikipedia.org/wiki/HTML5 "HyperText Markup Language версия 5"
[css3]: https://ru.wikipedia.org/wiki/CSS#Уровень_3_(CSS3) "Cascading Style Sheets уровень 3"
[js]: https://ru.wikipedia.org/wiki/JavaScript "Язык программирования JavaScript"
[paratype]: https://rus.paratype.ru/pt-sans-pt-serif "Шрифтовая система PT Sans, PT Serif и PT Mono"
[fontawesome]: https://fontawesome.com/ "Font Awesome"
[google-fonts]: https://fonts.google.com/ "Google Fonts"
[svg]: https://ru.wikipedia.org/wiki/SVG "Scalable Vector Graphics — масштабируемая векторная графика"
[yoomoney]: https://yoomoney.ru/ "ЮMoney"
[gce]: https://cse.google.com/ "Программируемая поисковая система"
[analytics]: https://analytics.google.com/ "Google Аналитика"
[metrica]: https://metrika.yandex.ru/ "Яндекс.Метрика"
[liquid]: https://shopify.github.io/liquid/ "Liquid template language"
[erb]: https://docs.ruby-lang.org/en/2.7.0/ERB.html "ERB — Ruby Templating"
[page-vars]: https://jekyllrb.com/docs/variables/#page-variables "Variables | Jekyll"
[jekyll-toc]: https://github.com/allejo/jekyll-toc
